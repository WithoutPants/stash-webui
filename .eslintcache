[{"/home/peroo/stash/ui/v2.5/src/App.tsx":"1","/home/peroo/stash/ui/v2.5/src/components/ErrorBoundary.tsx":"2","/home/peroo/stash/ui/v2.5/src/components/Galleries/Galleries.tsx":"3","/home/peroo/stash/ui/v2.5/src/components/Galleries/Gallery.tsx":"4","/home/peroo/stash/ui/v2.5/src/components/Galleries/GalleryList.tsx":"5","/home/peroo/stash/ui/v2.5/src/components/Galleries/GalleryViewer.tsx":"6","/home/peroo/stash/ui/v2.5/src/components/MainNavbar.tsx":"7","/home/peroo/stash/ui/v2.5/src/components/PageNotFound.tsx":"8","/home/peroo/stash/ui/v2.5/src/components/Settings/Settings.tsx":"9","/home/peroo/stash/ui/v2.5/src/components/Settings/SettingsAboutPanel.tsx":"10","/home/peroo/stash/ui/v2.5/src/components/Settings/SettingsConfigurationPanel.tsx":"11","/home/peroo/stash/ui/v2.5/src/components/Settings/SettingsInterfacePanel.tsx":"12","/home/peroo/stash/ui/v2.5/src/components/Settings/SettingsLogsPanel.tsx":"13","/home/peroo/stash/ui/v2.5/src/components/Settings/SettingsTasksPanel/GenerateButton.tsx":"14","/home/peroo/stash/ui/v2.5/src/components/Settings/SettingsTasksPanel/SettingsTasksPanel.tsx":"15","/home/peroo/stash/ui/v2.5/src/components/Shared/DetailsEditNavbar.tsx":"16","/home/peroo/stash/ui/v2.5/src/components/Shared/DurationInput.tsx":"17","/home/peroo/stash/ui/v2.5/src/components/Shared/FolderSelect/FolderSelect.tsx":"18","/home/peroo/stash/ui/v2.5/src/components/Shared/TagLink.tsx":"19","/home/peroo/stash/ui/v2.5/src/components/Shared/Toast.tsx":"20","/home/peroo/stash/ui/v2.5/src/components/Stats.tsx":"21","/home/peroo/stash/ui/v2.5/src/components/Studios/StudioCard.tsx":"22","/home/peroo/stash/ui/v2.5/src/components/Studios/StudioDetails/Studio.tsx":"23","/home/peroo/stash/ui/v2.5/src/components/Studios/StudioList.tsx":"24","/home/peroo/stash/ui/v2.5/src/components/Studios/Studios.tsx":"25","/home/peroo/stash/ui/v2.5/src/components/Tags/TagList.tsx":"26","/home/peroo/stash/ui/v2.5/src/components/Tags/Tags.tsx":"27","/home/peroo/stash/ui/v2.5/src/components/Wall/WallItem.tsx":"28","/home/peroo/stash/ui/v2.5/src/components/Wall/WallPanel.tsx":"29","/home/peroo/stash/ui/v2.5/src/components/list/AddFilter.tsx":"30","/home/peroo/stash/ui/v2.5/src/components/list/ListFilter.tsx":"31","/home/peroo/stash/ui/v2.5/src/components/list/Pagination.tsx":"32","/home/peroo/stash/ui/v2.5/src/components/performers/PerformerCard.tsx":"33","/home/peroo/stash/ui/v2.5/src/components/performers/PerformerDetails/Performer.tsx":"34","/home/peroo/stash/ui/v2.5/src/components/performers/PerformerList.tsx":"35","/home/peroo/stash/ui/v2.5/src/components/performers/PerformerListTable.tsx":"36","/home/peroo/stash/ui/v2.5/src/components/performers/performers.tsx":"37","/home/peroo/stash/ui/v2.5/src/components/scenes/SceneCard.tsx":"38","/home/peroo/stash/ui/v2.5/src/components/scenes/SceneDetails/Scene.tsx":"39","/home/peroo/stash/ui/v2.5/src/components/scenes/SceneDetails/SceneDetailPanel.tsx":"40","/home/peroo/stash/ui/v2.5/src/components/scenes/SceneDetails/SceneEditPanel.tsx":"41","/home/peroo/stash/ui/v2.5/src/components/scenes/SceneDetails/SceneFileInfoPanel.tsx":"42","/home/peroo/stash/ui/v2.5/src/components/scenes/SceneDetails/SceneMarkersPanel.tsx":"43","/home/peroo/stash/ui/v2.5/src/components/scenes/SceneDetails/ScenePerformerPanel.tsx":"44","/home/peroo/stash/ui/v2.5/src/components/scenes/SceneFilenameParser.tsx":"45","/home/peroo/stash/ui/v2.5/src/components/scenes/SceneList.tsx":"46","/home/peroo/stash/ui/v2.5/src/components/scenes/SceneListTable.tsx":"47","/home/peroo/stash/ui/v2.5/src/components/scenes/SceneMarkerList.tsx":"48","/home/peroo/stash/ui/v2.5/src/components/scenes/ScenePlayer/ScenePlayer.tsx":"49","/home/peroo/stash/ui/v2.5/src/components/scenes/ScenePlayer/ScenePlayerScrubber.tsx":"50","/home/peroo/stash/ui/v2.5/src/components/scenes/SceneSelectedOptions.tsx":"51","/home/peroo/stash/ui/v2.5/src/components/scenes/helpers.tsx":"52","/home/peroo/stash/ui/v2.5/src/components/scenes/scenes.tsx":"53","/home/peroo/stash/ui/v2.5/src/components/select/FilterMultiSelect.tsx":"54","/home/peroo/stash/ui/v2.5/src/components/select/FilterSelect.tsx":"55","/home/peroo/stash/ui/v2.5/src/components/select/MarkerTitleSuggest.tsx":"56","/home/peroo/stash/ui/v2.5/src/components/select/ScrapePerformerSuggest.tsx":"57","/home/peroo/stash/ui/v2.5/src/components/select/ValidGalleriesSelect.tsx":"58","/home/peroo/stash/ui/v2.5/src/core/StashService.ts":"59","/home/peroo/stash/ui/v2.5/src/core/generated-graphql.tsx":"60","/home/peroo/stash/ui/v2.5/src/hooks/ListHook.tsx":"61","/home/peroo/stash/ui/v2.5/src/hooks/LocalForage.ts":"62","/home/peroo/stash/ui/v2.5/src/hooks/VideoHover.ts":"63","/home/peroo/stash/ui/v2.5/src/index.tsx":"64","/home/peroo/stash/ui/v2.5/src/models/base-props.ts":"65","/home/peroo/stash/ui/v2.5/src/models/index.ts":"66","/home/peroo/stash/ui/v2.5/src/models/list-filter/criteria/criterion.ts":"67","/home/peroo/stash/ui/v2.5/src/models/list-filter/criteria/favorite.ts":"68","/home/peroo/stash/ui/v2.5/src/models/list-filter/criteria/has-markers.ts":"69","/home/peroo/stash/ui/v2.5/src/models/list-filter/criteria/is-missing.ts":"70","/home/peroo/stash/ui/v2.5/src/models/list-filter/criteria/none.ts":"71","/home/peroo/stash/ui/v2.5/src/models/list-filter/criteria/performers.ts":"72","/home/peroo/stash/ui/v2.5/src/models/list-filter/criteria/rating.ts":"73","/home/peroo/stash/ui/v2.5/src/models/list-filter/criteria/resolution.ts":"74","/home/peroo/stash/ui/v2.5/src/models/list-filter/criteria/studios.ts":"75","/home/peroo/stash/ui/v2.5/src/models/list-filter/criteria/tags.ts":"76","/home/peroo/stash/ui/v2.5/src/models/list-filter/criteria/utils.ts":"77","/home/peroo/stash/ui/v2.5/src/models/list-filter/filter.ts":"78","/home/peroo/stash/ui/v2.5/src/models/list-filter/types.ts":"79","/home/peroo/stash/ui/v2.5/src/models/react-images.d.ts":"80","/home/peroo/stash/ui/v2.5/src/models/react-jw-player.d.ts":"81","/home/peroo/stash/ui/v2.5/src/models/types.ts":"82","/home/peroo/stash/ui/v2.5/src/react-app-env.d.ts":"83","/home/peroo/stash/ui/v2.5/src/serviceWorker.ts":"84","/home/peroo/stash/ui/v2.5/src/utils/color.ts":"85","/home/peroo/stash/ui/v2.5/src/utils/editabletext.tsx":"86","/home/peroo/stash/ui/v2.5/src/utils/errors.ts":"87","/home/peroo/stash/ui/v2.5/src/utils/image.tsx":"88","/home/peroo/stash/ui/v2.5/src/utils/navigation.ts":"89","/home/peroo/stash/ui/v2.5/src/utils/table.tsx":"90","/home/peroo/stash/ui/v2.5/src/utils/text.ts":"91","/home/peroo/stash/ui/v2.5/src/utils/toasts.ts":"92","/home/peroo/stash/ui/v2.5/src/utils/zoom.ts":"93"},{"size":1818,"mtime":1578432843260,"results":"94","hashOfConfig":"95"},{"size":769,"mtime":1577979127060,"results":"96","hashOfConfig":"95"},{"size":364,"mtime":1577979127060,"results":"97","hashOfConfig":"95"},{"size":1061,"mtime":1578153870063,"results":"98","hashOfConfig":"95"},{"size":1891,"mtime":1578153881712,"results":"99","hashOfConfig":"95"},{"size":1440,"mtime":1578153898526,"results":"100","hashOfConfig":"95"},{"size":2043,"mtime":1577994497113,"results":"101","hashOfConfig":"95"},{"size":154,"mtime":1577979127060,"results":"102","hashOfConfig":"95"},{"size":1885,"mtime":1577979127120,"results":"103","hashOfConfig":"95"},{"size":1109,"mtime":1578154008447,"results":"104","hashOfConfig":"95"},{"size":9581,"mtime":1578153404628,"results":"105","hashOfConfig":"95"},{"size":4412,"mtime":1578153807337,"results":"106","hashOfConfig":"95"},{"size":5105,"mtime":1578151803148,"results":"107","hashOfConfig":"95"},{"size":1767,"mtime":1577979127140,"results":"108","hashOfConfig":"95"},{"size":7437,"mtime":1578151882758,"results":"109","hashOfConfig":"95"},{"size":4140,"mtime":1578083340244,"results":"110","hashOfConfig":"95"},{"size":2898,"mtime":1578077797211,"results":"111","hashOfConfig":"95"},{"size":2923,"mtime":1578078846876,"results":"112","hashOfConfig":"95"},{"size":1174,"mtime":1578006626029,"results":"113","hashOfConfig":"95"},{"size":1319,"mtime":1578435714803,"results":"114","hashOfConfig":"95"},{"size":1957,"mtime":1577992677258,"results":"115","hashOfConfig":"95"},{"size":721,"mtime":1578076709401,"results":"116","hashOfConfig":"95"},{"size":5067,"mtime":1578076542562,"results":"117","hashOfConfig":"95"},{"size":1328,"mtime":1578153890219,"results":"118","hashOfConfig":"95"},{"size":364,"mtime":1577979127156,"results":"119","hashOfConfig":"95"},{"size":4672,"mtime":1578057682269,"results":"120","hashOfConfig":"95"},{"size":244,"mtime":1577979127172,"results":"121","hashOfConfig":"95"},{"size":4925,"mtime":1578153782630,"results":"122","hashOfConfig":"95"},{"size":2720,"mtime":1578153906690,"results":"123","hashOfConfig":"95"},{"size":7005,"mtime":1578299498166,"results":"124","hashOfConfig":"95"},{"size":7997,"mtime":1578172709206,"results":"125","hashOfConfig":"95"},{"size":3262,"mtime":1578165098978,"results":"126","hashOfConfig":"95"},{"size":1462,"mtime":1578083893006,"results":"127","hashOfConfig":"95"},{"size":13899,"mtime":1578086127588,"results":"128","hashOfConfig":"95"},{"size":2485,"mtime":1577979127184,"results":"129","hashOfConfig":"95"},{"size":2554,"mtime":1578084209211,"results":"130","hashOfConfig":"95"},{"size":397,"mtime":1577979127192,"results":"131","hashOfConfig":"95"},{"size":7168,"mtime":1578054332821,"results":"132","hashOfConfig":"95"},{"size":3737,"mtime":1578004207025,"results":"133","hashOfConfig":"95"},{"size":1381,"mtime":1578006480744,"results":"134","hashOfConfig":"95"},{"size":12685,"mtime":1578301620208,"results":"135","hashOfConfig":"95"},{"size":3133,"mtime":1577997627561,"results":"136","hashOfConfig":"95"},{"size":9231,"mtime":1578301845641,"results":"137","hashOfConfig":"95"},{"size":618,"mtime":1577979127196,"results":"138","hashOfConfig":"95"},{"size":29391,"mtime":1578301950830,"results":"139","hashOfConfig":"95"},{"size":3809,"mtime":1577994701125,"results":"140","hashOfConfig":"95"},{"size":3028,"mtime":1577996569786,"results":"141","hashOfConfig":"95"},{"size":2299,"mtime":1577979127196,"results":"142","hashOfConfig":"95"},{"size":5740,"mtime":1578054177135,"results":"143","hashOfConfig":"95"},{"size":10525,"mtime":1578154075579,"results":"144","hashOfConfig":"95"},{"size":8943,"mtime":1578302106743,"results":"145","hashOfConfig":"95"},{"size":905,"mtime":1577996960389,"results":"146","hashOfConfig":"95"},{"size":484,"mtime":1577979127227,"results":"147","hashOfConfig":"95"},{"size":6514,"mtime":1577979127227,"results":"148","hashOfConfig":"95"},{"size":5127,"mtime":1578435644103,"results":"149","hashOfConfig":"95"},{"size":2275,"mtime":1577979127227,"results":"150","hashOfConfig":"95"},{"size":2608,"mtime":1578153443601,"results":"151","hashOfConfig":"95"},{"size":2695,"mtime":1578151970904,"results":"152","hashOfConfig":"95"},{"size":16285,"mtime":1578426905076,"results":"153","hashOfConfig":"95"},{"size":73414,"mtime":1577979127231,"results":"154","hashOfConfig":"95"},{"size":11366,"mtime":1577979127231,"results":"155","hashOfConfig":"95"},{"size":1659,"mtime":1577979127231,"results":"156","hashOfConfig":"95"},{"size":2144,"mtime":1577979127231,"results":"157","hashOfConfig":"95"},{"size":737,"mtime":1577993631244,"results":"158","hashOfConfig":"95"},{"size":124,"mtime":1577979127235,"results":"159","hashOfConfig":"95"},{"size":55,"mtime":1577979127235,"results":"160","hashOfConfig":"95"},{"size":6822,"mtime":1578164766969,"results":"161","hashOfConfig":"95"},{"size":659,"mtime":1577979127255,"results":"162","hashOfConfig":"95"},{"size":664,"mtime":1577979127255,"results":"163","hashOfConfig":"95"},{"size":682,"mtime":1577979127255,"results":"164","hashOfConfig":"95"},{"size":566,"mtime":1577979127255,"results":"165","hashOfConfig":"95"},{"size":966,"mtime":1577979127255,"results":"166","hashOfConfig":"95"},{"size":1013,"mtime":1577979127255,"results":"167","hashOfConfig":"95"},{"size":694,"mtime":1577979127255,"results":"168","hashOfConfig":"95"},{"size":881,"mtime":1577979127255,"results":"169","hashOfConfig":"95"},{"size":1287,"mtime":1577979127255,"results":"170","hashOfConfig":"95"},{"size":1965,"mtime":1577979127255,"results":"171","hashOfConfig":"95"},{"size":12393,"mtime":1577979127255,"results":"172","hashOfConfig":"95"},{"size":278,"mtime":1577979127255,"results":"173","hashOfConfig":"95"},{"size":187,"mtime":1577979127255,"results":"174","hashOfConfig":"95"},{"size":200,"mtime":1577979127255,"results":"175","hashOfConfig":"95"},{"size":74,"mtime":1577979127255,"results":"176","hashOfConfig":"95"},{"size":40,"mtime":1577979127255,"results":"177","hashOfConfig":"95"},{"size":5216,"mtime":1577979127287,"results":"178","hashOfConfig":"95"},{"size":308,"mtime":1577979127287,"results":"179","hashOfConfig":"95"},{"size":1871,"mtime":1577979127287,"results":"180","hashOfConfig":"95"},{"size":529,"mtime":1577979127287,"results":"181","hashOfConfig":"95"},{"size":1049,"mtime":1578153858370,"results":"182","hashOfConfig":"95"},{"size":2396,"mtime":1577979127287,"results":"183","hashOfConfig":"95"},{"size":3507,"mtime":1578302319327,"results":"184","hashOfConfig":"95"},{"size":2241,"mtime":1577979127287,"results":"185","hashOfConfig":"95"},{"size":275,"mtime":1577979127287,"results":"186","hashOfConfig":"95"},{"size":123,"mtime":1577979127319,"results":"187","hashOfConfig":"95"},{"filePath":"188","messages":"189","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1tsnfwq",{"filePath":"190","messages":"191","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"192","messages":"193","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"194","messages":"195","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"196"},{"filePath":"197","messages":"198","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"199","messages":"200","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"201","messages":"202","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"203","messages":"204","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"205","messages":"206","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"207"},{"filePath":"208","messages":"209","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"210","messages":"211","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"212"},{"filePath":"213","messages":"214","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"215"},{"filePath":"216","messages":"217","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"218"},{"filePath":"219","messages":"220","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"221","messages":"222","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"223","messages":"224","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"225","messages":"226","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"227","messages":"228","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"229","messages":"230","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"231","messages":"232","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"233","messages":"234","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"235","messages":"236","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"237","messages":"238","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"239","messages":"240","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"241","messages":"242","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"243","messages":"244","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"245","messages":"246","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"247","messages":"248","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"249","messages":"250","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"251","messages":"252","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"253","messages":"254","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"255","messages":"256","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"257","messages":"258","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"259","messages":"260","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"261"},{"filePath":"262","messages":"263","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"264","messages":"265","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"266","messages":"267","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"268","messages":"269","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"270","messages":"271","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"272"},{"filePath":"273","messages":"274","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"275","messages":"276","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"277","messages":"278","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"279","messages":"280","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"281","messages":"282","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"283","messages":"284","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"285"},{"filePath":"286","messages":"287","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"288","messages":"289","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"290","messages":"291","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"292","messages":"293","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"294","messages":"295","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":2,"source":"296"},{"filePath":"297","messages":"298","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"299","messages":"300","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"301","messages":"302","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"303","messages":"304","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":1,"source":"305"},{"filePath":"306","messages":"307","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"308","messages":"309","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"310","messages":"311","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"312","messages":"313","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"314","messages":"315","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"316","messages":"317","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"318","messages":"319","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"320"},{"filePath":"321","messages":"322","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"323","messages":"324","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"325","messages":"326","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"327","messages":"328","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"329","messages":"330","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"331","messages":"332","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"333","messages":"334","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"335","messages":"336","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"337","messages":"338","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"339","messages":"340","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"341","messages":"342","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"343","messages":"344","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"345","messages":"346","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"347","messages":"348","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"349","messages":"350","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"351","messages":"352","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"353","messages":"354","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"355","messages":"356","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"357","messages":"358","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"359","messages":"360","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"361","messages":"362","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"363","messages":"364","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"365","messages":"366","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"367","messages":"368","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"369","messages":"370","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"371","messages":"372","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"373","messages":"374","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"375","messages":"376","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"377","messages":"378","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"379","messages":"380","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"381"},{"filePath":"382","messages":"383","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"384","messages":"385","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/home/peroo/stash/ui/v2.5/src/App.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/ErrorBoundary.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/Galleries/Galleries.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/Galleries/Gallery.tsx",["386"],"import React, { useEffect, useState } from \"react\";\nimport { Spinner } from 'react-bootstrap';\nimport * as GQL from \"../../core/generated-graphql\";\nimport { StashService } from \"../../core/StashService\";\nimport { IBaseProps } from \"../../models\";\nimport { GalleryViewer } from \"./GalleryViewer\";\n\ninterface IProps extends IBaseProps {}\n\nexport const Gallery: React.FC<IProps> = (props: IProps) => {\n  const [gallery, setGallery] = useState<Partial<GQL.GalleryDataFragment>>({});\n  const [isLoading, setIsLoading] = useState(false);\n\n  const { data, error, loading } = StashService.useFindGallery(props.match.params.id);\n\n  useEffect(() => {\n    setIsLoading(loading);\n    if (!data || !data.findGallery || !!error) { return; }\n    setGallery(data.findGallery);\n  }, [data]);\n\n  if (!data || !data.findGallery || isLoading) { return <Spinner animation=\"border\" variant=\"light\" />; }\n  if (!!error) { return <>{error.message}</>; }\n  return (\n    <div style={{width: \"75vw\", margin: \"0 auto\"}}>\n      <GalleryViewer gallery={gallery as any} />\n    </div>\n  );\n};\n","/home/peroo/stash/ui/v2.5/src/components/Galleries/GalleryList.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/Galleries/GalleryViewer.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/MainNavbar.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/PageNotFound.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/Settings/Settings.tsx",["387"],"import {\n  Card,\n  Tab,\n  Tabs,\n} from \"@blueprintjs/core\";\nimport queryString from \"query-string\";\nimport React, { FunctionComponent, useEffect, useState } from \"react\";\nimport { IBaseProps } from \"../../models\";\nimport { SettingsAboutPanel } from \"./SettingsAboutPanel\";\nimport { SettingsConfigurationPanel } from \"./SettingsConfigurationPanel\";\nimport { SettingsInterfacePanel } from \"./SettingsInterfacePanel\";\nimport { SettingsLogsPanel } from \"./SettingsLogsPanel\";\nimport { SettingsTasksPanel } from \"./SettingsTasksPanel/SettingsTasksPanel\";\n\ninterface IProps extends IBaseProps {}\n\ntype TabId = \"configuration\" | \"tasks\" | \"logs\" | \"about\";\n\nexport const Settings: FunctionComponent<IProps> = (props: IProps) => {\n  const [tabId, setTabId] = useState<TabId>(getTabId());\n\n  useEffect(() => {\n    const location = Object.assign({}, props.history.location);\n    location.search = queryString.stringify({tab: tabId}, {encode: false});\n    props.history.replace(location);\n  }, [tabId]);\n\n  function getTabId(): TabId {\n    const queryParams = queryString.parse(props.location.search);\n    if (!queryParams.tab || typeof queryParams.tab !== \"string\") { return \"tasks\"; }\n    return queryParams.tab as TabId;\n  }\n\n  return (\n    <Card id=\"details-container\">\n      <Tabs\n        renderActiveTabPanelOnly={true}\n        vertical={true}\n        onChange={(newId) => setTabId(newId as TabId)}\n        defaultSelectedTabId={getTabId()}\n      >\n        <Tab id=\"configuration\" title=\"Configuration\" panel={<SettingsConfigurationPanel />} />\n        <Tab id=\"interface\" title=\"Interface Configuration\" panel={<SettingsInterfacePanel />} />\n        <Tab id=\"tasks\" title=\"Tasks\" panel={<SettingsTasksPanel />} />\n        <Tab id=\"logs\" title=\"Logs\" panel={<SettingsLogsPanel />} />\n        <Tab id=\"about\" title=\"About\" panel={<SettingsAboutPanel />} />\n      </Tabs>\n    </Card>\n  );\n};\n","/home/peroo/stash/ui/v2.5/src/components/Settings/SettingsAboutPanel.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/Settings/SettingsConfigurationPanel.tsx",["388"],"import {\n  AnchorButton,\n  Button,\n  Divider,\n  FormGroup,\n  InputGroup,\n  Spinner,\n  Checkbox,\n  HTMLSelect,\n} from \"@blueprintjs/core\";\nimport React, { useEffect, useState } from \"react\";\nimport * as GQL from \"../../core/generated-graphql\";\nimport { StashService } from \"../../core/StashService\";\nimport { ErrorUtils } from \"../../utils/errors\";\nimport { ToastUtils } from \"../../utils/toasts\";\nimport { FolderSelect } from \"../Shared/FolderSelect/FolderSelect\";\n\nexport const SettingsConfigurationPanel: React.FC = () => {\n  // Editing config state\n  const [stashes, setStashes] = useState<string[]>([]);\n  const [databasePath, setDatabasePath] = useState<string | undefined>(undefined);\n  const [generatedPath, setGeneratedPath] = useState<string | undefined>(undefined);\n  const [maxTranscodeSize, setMaxTranscodeSize] = useState<GQL.StreamingResolutionEnum | undefined>(undefined);\n  const [maxStreamingTranscodeSize, setMaxStreamingTranscodeSize] = useState<GQL.StreamingResolutionEnum | undefined>(undefined);\n  const [username, setUsername] = useState<string | undefined>(undefined);\n  const [password, setPassword] = useState<string | undefined>(undefined);\n  const [logFile, setLogFile] = useState<string | undefined>();\n  const [logOut, setLogOut] = useState<boolean>(true);\n  const [logLevel, setLogLevel] = useState<string>(\"Info\");\n  const [logAccess, setLogAccess] = useState<boolean>(true);\n  const [excludes, setExcludes] = useState<(string)[]>([]);\n\n  const { data, error, loading } = StashService.useConfiguration();\n\n  const updateGeneralConfig = StashService.useConfigureGeneral({\n    stashes,\n    databasePath,\n    generatedPath,\n    maxTranscodeSize,\n    maxStreamingTranscodeSize,\n    username,\n    password,\n    logFile,\n    logOut,\n    logLevel,\n    logAccess,\n    excludes,\n  });\n\n  useEffect(() => {\n    if (!data || !data.configuration || !!error) { return; }\n    const conf = StashService.nullToUndefined(data.configuration) as GQL.ConfigDataFragment;\n    if (!!conf.general) {\n      setStashes(conf.general.stashes || []);\n      setDatabasePath(conf.general.databasePath);\n      setGeneratedPath(conf.general.generatedPath);\n      setMaxTranscodeSize(conf.general.maxTranscodeSize);\n      setMaxStreamingTranscodeSize(conf.general.maxStreamingTranscodeSize);\n      setUsername(conf.general.username);\n      setPassword(conf.general.password);\n      setLogFile(conf.general.logFile);\n      setLogOut(conf.general.logOut);\n      setLogLevel(conf.general.logLevel);\n      setLogAccess(conf.general.logAccess);\n      setExcludes(conf.general.excludes);\n    }\n  }, [data]);\n\n  function onStashesChanged(directories: string[]) {\n    setStashes(directories);\n  }\n\n  function excludeRegexChanged(idx: number, value: string) {\n    const newExcludes = excludes.map((regex, i)=> {\n      const ret = ( idx !== i ) ? regex : value ;\n      return ret\n      })\n    setExcludes(newExcludes);\n  }\n\n  function excludeRemoveRegex(idx: number) {\n    const newExcludes = excludes.filter((_regex, i) => i !== idx );\n\n    setExcludes(newExcludes);\n  }\n\n  function excludeAddRegex() {\n    const demo = \"sample\\\\.mp4$\"\n    const newExcludes = excludes.concat(demo);\n\n    setExcludes(newExcludes);\n  }\n\n\n  async function onSave() {\n    try {\n      const result = await updateGeneralConfig();\n      console.log(result);\n      ToastUtils.success(\"Updated config\");\n    } catch (e) {\n      ErrorUtils.handle(e);\n    }\n  }\n\n  const transcodeQualities = [\n    GQL.StreamingResolutionEnum.Low,\n    GQL.StreamingResolutionEnum.Standard,\n    GQL.StreamingResolutionEnum.StandardHd,\n    GQL.StreamingResolutionEnum.FullHd,\n    GQL.StreamingResolutionEnum.FourK,\n    GQL.StreamingResolutionEnum.Original\n  ].map(resolutionToString);\n\n  function resolutionToString(r : GQL.StreamingResolutionEnum | undefined) {\n    switch (r) {\n      case GQL.StreamingResolutionEnum.Low: return \"240p\";\n      case GQL.StreamingResolutionEnum.Standard: return \"480p\";\n      case GQL.StreamingResolutionEnum.StandardHd: return \"720p\";\n      case GQL.StreamingResolutionEnum.FullHd: return \"1080p\";\n      case GQL.StreamingResolutionEnum.FourK: return \"4k\";\n      case GQL.StreamingResolutionEnum.Original: return \"Original\";\n    }\n\n    return \"Original\";\n  }\n\n  function translateQuality(quality : string) {\n    switch (quality) {\n      case \"240p\": return GQL.StreamingResolutionEnum.Low;\n      case \"480p\": return GQL.StreamingResolutionEnum.Standard;\n      case \"720p\": return GQL.StreamingResolutionEnum.StandardHd;\n      case \"1080p\": return GQL.StreamingResolutionEnum.FullHd;\n      case \"4k\": return GQL.StreamingResolutionEnum.FourK;\n      case \"Original\": return GQL.StreamingResolutionEnum.Original;\n    }\n\n    return GQL.StreamingResolutionEnum.Original;\n  }\n\n  return (\n    <>\n      {!!error ? <h1>{error.message}</h1> : undefined}\n      {(!data || !data.configuration || loading) ? <Spinner size={Spinner.SIZE_LARGE} /> : undefined}\n      <h4>Library</h4>\n      <FormGroup>\n        <FormGroup>\n          <FormGroup\n            label=\"Stashes\"\n            helperText=\"Directory locations to your content\"\n          >\n            <FolderSelect\n              directories={stashes}\n              onDirectoriesChanged={onStashesChanged}\n            />\n          </FormGroup>\n        </FormGroup>\n        \n        <FormGroup\n          label=\"Database Path\"\n          helperText=\"File location for the SQLite database (requires restart)\"\n        >\n          <InputGroup value={databasePath} onChange={(e: any) => setDatabasePath(e.target.value)} />\n        </FormGroup>\n\n        <FormGroup\n          label=\"Generated Path\"\n          helperText=\"Directory location for the generated files (scene markers, scene previews, sprites, etc)\"\n        >\n          <InputGroup value={generatedPath} onChange={(e: any) => setGeneratedPath(e.target.value)} />\n        </FormGroup>\n\n        <FormGroup\n          label=\"Excluded Patterns\"\n        >\n\n       { (excludes) ? excludes.map((regexp, i) => {\n         return(\n           <InputGroup\n             value={regexp}\n             onChange={(e: any) => excludeRegexChanged(i, e.target.value)}\n             rightElement={<Button icon=\"minus\" minimal={true} intent=\"danger\" onClick={(e: any) => excludeRemoveRegex(i)} />}\n           />\n           );\n         }) : null\n       }\n\n          <Button icon=\"plus\" minimal={true} onClick={(e: any) => excludeAddRegex()} />\n          <div>\n            <p>\n              <AnchorButton\n                href=\"https://github.com/stashapp/stash/wiki/Exclude-file-configuration\"\n                rightIcon=\"help\"\n                text=\"Regexps of files/paths to exclude from Scan and add to Clean\"\n                minimal={true}\n                target=\"_blank\" \n              />\n            </p>\n          </div>\n        </FormGroup>\n      </FormGroup>\n      \n      <Divider />\n        <FormGroup>\n          <h4>Video</h4>\n          <FormGroup \n            label=\"Maximum transcode size\"\n            helperText=\"Maximum size for generated transcodes\"\n          >\n            <HTMLSelect\n              options={transcodeQualities}\n              onChange={(event) => setMaxTranscodeSize(translateQuality(event.target.value))}\n              value={resolutionToString(maxTranscodeSize)}\n            />\n          </FormGroup>\n          <FormGroup \n            label=\"Maximum streaming transcode size\"\n            helperText=\"Maximum size for transcoded streams\"\n          >\n            <HTMLSelect\n              options={transcodeQualities}\n              onChange={(event) => setMaxStreamingTranscodeSize(translateQuality(event.target.value))}\n              value={resolutionToString(maxStreamingTranscodeSize)}\n            />\n          </FormGroup>\n        </FormGroup>\n      <Divider />\n\n      <FormGroup>\n        <h4>Authentication</h4>\n        <FormGroup\n          label=\"Username\"\n          helperText=\"Username to access Stash. Leave blank to disable user authentication\"\n        >\n          <InputGroup value={username} onChange={(e: any) => setUsername(e.target.value)} />\n        </FormGroup>\n        <FormGroup\n          label=\"Password\"\n          helperText=\"Password to access Stash. Leave blank to disable user authentication\"\n        >\n          <InputGroup type=\"password\" value={password} onChange={(e: any) => setPassword(e.target.value)} />\n        </FormGroup>\n      </FormGroup>\n\n      <Divider />\n      <h4>Logging</h4>\n      <FormGroup\n        label=\"Log file\"\n        helperText=\"Path to the file to output logging to. Blank to disable file logging. Requires restart.\"\n      >\n        <InputGroup value={logFile} onChange={(e: any) => setLogFile(e.target.value)} />\n      </FormGroup>\n\n      <FormGroup\n        helperText=\"Logs to the terminal in addition to a file. Always true if file logging is disabled. Requires restart.\"\n      >\n        <Checkbox\n          checked={logOut}\n          label=\"Log to terminal\"\n          onChange={() => setLogOut(!logOut)}\n        />\n      </FormGroup>\n\n      <FormGroup inline={true} label=\"Log Level\">\n        <HTMLSelect\n          options={[\"Debug\", \"Info\", \"Warning\", \"Error\"]}\n          onChange={(event) => setLogLevel(event.target.value)}\n          value={logLevel}\n        />\n      </FormGroup>\n\n      <FormGroup\n        helperText=\"Logs http access to the terminal. Requires restart.\"\n      >\n        <Checkbox\n          checked={logAccess}\n          label=\"Log http access\"\n          onChange={() => setLogAccess(!logAccess)}\n        />\n      </FormGroup>\n\n      <Divider />\n      <Button intent=\"primary\" onClick={() => onSave()}>Save</Button>\n    </>\n  );\n};\n","/home/peroo/stash/ui/v2.5/src/components/Settings/SettingsInterfacePanel.tsx",["389"],"import {\n  Button,\n  Checkbox,\n  Divider,\n  FormGroup,\n  Spinner,\n  TextArea,\n  NumericInput\n} from \"@blueprintjs/core\";\nimport React, { FunctionComponent, useEffect, useState } from \"react\";\nimport { StashService } from \"../../core/StashService\";\nimport { ErrorUtils } from \"../../utils/errors\";\nimport { ToastUtils } from \"../../utils/toasts\";\n\ninterface IProps {}\n\nexport const SettingsInterfacePanel: FunctionComponent<IProps> = () => {\n  const config = StashService.useConfiguration();\n  const [soundOnPreview, setSoundOnPreview] = useState<boolean>();\n  const [wallShowTitle, setWallShowTitle] = useState<boolean>();\n  const [maximumLoopDuration, setMaximumLoopDuration] = useState<number>(0);\n  const [autostartVideo, setAutostartVideo] = useState<boolean>();\n  const [showStudioAsText, setShowStudioAsText] = useState<boolean>();\n  const [css, setCSS] = useState<string>();\n  const [cssEnabled, setCSSEnabled] = useState<boolean>();\n\n  const updateInterfaceConfig = StashService.useConfigureInterface({\n    soundOnPreview,\n    wallShowTitle,\n    maximumLoopDuration,\n    autostartVideo,\n    showStudioAsText,\n    css,\n    cssEnabled\n  });\n\n  useEffect(() => {\n    if (!config.data || !config.data.configuration || !!config.error) { return; }\n    if (!!config.data.configuration.interface) {\n      let iCfg = config.data.configuration.interface;\n      setSoundOnPreview(iCfg.soundOnPreview !== undefined ? iCfg.soundOnPreview : true);\n      setWallShowTitle(iCfg.wallShowTitle !== undefined ? iCfg.wallShowTitle : true);\n      setMaximumLoopDuration(iCfg.maximumLoopDuration || 0);\n      setAutostartVideo(iCfg.autostartVideo !== undefined ? iCfg.autostartVideo : false);\n      setShowStudioAsText(iCfg.showStudioAsText !== undefined ? iCfg.showStudioAsText : false);\n      setCSS(config.data.configuration.interface.css || \"\");\n      setCSSEnabled(config.data.configuration.interface.cssEnabled || false);\n    }\n  }, [config.data]);\n\n  async function onSave() {\n    try {\n      const result = await updateInterfaceConfig();\n      console.log(result);\n      ToastUtils.success(\"Updated config\");\n    } catch (e) {\n      ErrorUtils.handle(e);\n    }\n  }\n\n  return (\n    <>\n      {!!config.error ? <h1>{config.error.message}</h1> : undefined}\n      {(!config.data || !config.data.configuration || config.loading) ? <Spinner size={Spinner.SIZE_LARGE} /> : undefined}\n      <h4>User Interface</h4>\n      <FormGroup\n        label=\"Scene / Marker Wall\"\n        helperText=\"Configuration for wall items\"\n      >\n        <Checkbox\n          checked={wallShowTitle}\n          label=\"Display title and tags\"\n          onChange={() => setWallShowTitle(!wallShowTitle)}\n        />\n        <Checkbox\n          checked={soundOnPreview}\n          label=\"Enable sound\"\n          onChange={() => setSoundOnPreview(!soundOnPreview)}\n        />\n      </FormGroup>\n\n      <FormGroup\n        label=\"Scene List\"\n      >\n        <Checkbox\n          checked={showStudioAsText}\n          label=\"Show Studios as text\"\n          onChange={() => {\n            setShowStudioAsText(!showStudioAsText)\n          }}\n        />\n      </FormGroup>\n      \n      <FormGroup\n        label=\"Scene Player\"\n      >\n        <Checkbox\n          checked={autostartVideo}\n          label=\"Auto-start video\"\n          onChange={() => {\n            setAutostartVideo(!autostartVideo)\n          }}\n        />\n\n        <FormGroup\n          label=\"Maximum loop duration\"\n          helperText=\"Maximum scene duration - in seconds - where scene player will loop the video - 0 to disable\"\n        >\n          <NumericInput \n            value={maximumLoopDuration} \n            type=\"number\"\n            onValueChange={(value: number) => setMaximumLoopDuration(value)}\n            min={0}\n            minorStepSize={1}\n          />\n        </FormGroup>\n      </FormGroup>\n\n      <FormGroup\n        label=\"Custom CSS\"\n        helperText=\"Page must be reloaded for changes to take effect.\"\n      >\n        <Checkbox\n          checked={cssEnabled}\n          label=\"Custom CSS enabled\"\n          onChange={() => {\n            setCSSEnabled(!cssEnabled)\n          }}\n        />\n\n        <TextArea \n          value={css} \n          onChange={(e: any) => setCSS(e.target.value)}\n          fill={true}\n          rows={16}>\n        </TextArea>\n      </FormGroup>\n\n      <Divider />\n      <Button intent=\"primary\" onClick={() => onSave()}>Save</Button>\n    </>\n  );\n};\n","/home/peroo/stash/ui/v2.5/src/components/Settings/SettingsLogsPanel.tsx",["390","391","392"],"import {\n  H4, FormGroup, HTMLSelect,\n} from \"@blueprintjs/core\";\nimport React, { FunctionComponent, useState, useEffect, useRef } from \"react\";\nimport * as GQL from \"../../core/generated-graphql\";\nimport { StashService } from \"../../core/StashService\";\n\ninterface IProps {}\n\nfunction convertTime(logEntry : GQL.LogEntryDataFragment) {\n  function pad(val : number) {\n    var ret = val.toString();\n    if (val <= 9) {\n      ret = \"0\" + ret;\n    }\n\n    return ret;\n  }\n\n  var date = new Date(logEntry.time);\n  var month = date.getMonth() + 1;\n  var day = date.getDate();\n  var dateStr = date.getFullYear() + \"-\" + pad(month) + \"-\" + pad(day);\n  dateStr += \" \" + pad(date.getHours()) + \":\" + pad(date.getMinutes()) + \":\" + pad(date.getSeconds());\n\n  return dateStr;\n}\n\nclass LogEntry {\n  public time: string;\n  public level: string;\n  public message: string;\n  public id: string;\n\n  private static nextId: number = 0;\n\n  public constructor(logEntry: GQL.LogEntryDataFragment) {\n    this.time = convertTime(logEntry);\n    this.level = logEntry.level;\n    this.message = logEntry.message;\n\n    var id = LogEntry.nextId++;\n    this.id = id.toString();\n  }\n}\n\nexport const SettingsLogsPanel: FunctionComponent<IProps> = (props: IProps) => {\n  const { data, error } = StashService.useLoggingSubscribe();\n  const { data: existingData } = StashService.useLogs();\n  \n  const logEntries = useRef<LogEntry[]>([]);\n  const [logLevel, setLogLevel] = useState<string>(\"Info\");\n  const [filteredLogEntries, setFilteredLogEntries] = useState<LogEntry[]>([]);\n  const lastUpdate = useRef<number>(0);\n  const updateTimeout = useRef<NodeJS.Timeout>();\n\n  // maximum number of log entries to display. Subsequent entries will truncate \n  // the list, dropping off the oldest entries first.\n  const MAX_LOG_ENTRIES = 200;\n\n  function truncateLogEntries(entries : LogEntry[]) {\n    entries.length = Math.min(entries.length, MAX_LOG_ENTRIES);\n  }\n\n  function prependLogEntries(toPrepend : LogEntry[]) {\n    var newLogEntries = toPrepend.concat(logEntries.current);\n    truncateLogEntries(newLogEntries);\n    logEntries.current = newLogEntries;\n  }\n\n  function appendLogEntries(toAppend : LogEntry[]) {\n    var newLogEntries = logEntries.current.concat(toAppend);\n    truncateLogEntries(newLogEntries);\n    logEntries.current = newLogEntries;\n  }\n\n  useEffect(() => {\n    if (!data) { return; }\n\n    // append data to the logEntries\n    var convertedData = data.loggingSubscribe.map(convertLogEntry);\n\n    // filter subscribed data as it comes in, otherwise we'll end up\n    // truncating stuff that wasn't filtered out\n    convertedData = convertedData.filter(filterByLogLevel)\n    \n    // put newest entries at the top\n    convertedData.reverse();\n    prependLogEntries(convertedData);\n\n    updateFilteredEntries();\n  }, [data]);\n\n  useEffect(() => {\n    if (!existingData || !existingData.logs) { return; }\n\n    var convertedData = existingData.logs.map(convertLogEntry);\n    appendLogEntries(convertedData);\n\n    updateFilteredEntries();\n  }, [existingData]);\n\n  function updateFilteredEntries() {\n    if (!updateTimeout.current) {\n      console.log(\"Updating after timeout\");\n    }\n    updateTimeout.current = undefined;\n\n    var filteredEntries = logEntries.current.filter(filterByLogLevel);\n    setFilteredLogEntries(filteredEntries);\n\n    lastUpdate.current = new Date().getTime();\n  }\n\n  useEffect(() => {\n    updateFilteredEntries();\n  }, [logLevel]);\n\n  function convertLogEntry(logEntry : GQL.LogEntryDataFragment) {\n    return new LogEntry(logEntry);\n  }\n\n  function levelClass(level : string) {\n    return level.toLowerCase().trim();\n  }\n\n  interface ILogElementProps {\n    logEntry : LogEntry\n  }\n\n  function LogElement(props : ILogElementProps) {\n    // pad to maximum length of level enum\n    var level = props.logEntry.level.padEnd(GQL.LogLevel.Progress.length);\n\n    return (\n      <>\n        <span>{props.logEntry.time}</span>&nbsp;\n        <span className={levelClass(props.logEntry.level)}>{level}</span>&nbsp;\n        <span>{props.logEntry.message}</span>\n        <br/>\n      </>\n    );\n  }\n\n  function maybeRenderError() {\n    if (error) {\n      return (\n        <>\n        <span className={\"error\"}>Error connecting to log server: {error.message}</span><br/>\n        </>\n      );\n    }\n  }\n\n  const logLevels = [\"Debug\", \"Info\", \"Warning\", \"Error\"];\n\n  function filterByLogLevel(logEntry : LogEntry) {\n    if (logLevel === \"Debug\") {\n      return true;\n    }\n\n    var logLevelIndex = logLevels.indexOf(logLevel);\n    var levelIndex = logLevels.indexOf(logEntry.level);\n\n    return levelIndex >= logLevelIndex;\n  }\n\n  return (\n    <>\n      <H4>Logs</H4>\n      <div>\n      <FormGroup inline={true} label=\"Log Level\">\n        <HTMLSelect\n          options={logLevels}\n          onChange={(event) => setLogLevel(event.target.value)}\n          value={logLevel}\n        />\n        </FormGroup>\n      </div>\n      <div className=\"logs\">\n        {maybeRenderError()}\n        {filteredLogEntries.map((logEntry) =>\n          <LogElement logEntry={logEntry} key={logEntry.id}/>\n        )}\n      </div>\n    </>\n  );\n};\n","/home/peroo/stash/ui/v2.5/src/components/Settings/SettingsTasksPanel/GenerateButton.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/Settings/SettingsTasksPanel/SettingsTasksPanel.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/Shared/DetailsEditNavbar.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/Shared/DurationInput.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/Shared/FolderSelect/FolderSelect.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/Shared/TagLink.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/Shared/Toast.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/Stats.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/Studios/StudioCard.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/Studios/StudioDetails/Studio.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/Studios/StudioList.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/Studios/Studios.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/Tags/TagList.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/Tags/Tags.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/Wall/WallItem.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/Wall/WallPanel.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/list/AddFilter.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/list/ListFilter.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/list/Pagination.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/performers/PerformerCard.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/performers/PerformerDetails/Performer.tsx",["393","394"],"import _ from \"lodash\";\nimport { Button, Form, Modal, Spinner, Table } from 'react-bootstrap';\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport React, { useEffect, useState } from \"react\";\nimport * as GQL from \"../../../core/generated-graphql\";\nimport { StashService } from \"../../../core/StashService\";\nimport { IBaseProps } from \"../../../models\";\nimport { ErrorUtils } from \"../../../utils/errors\";\nimport { TableUtils } from \"../../../utils/table\";\nimport { ScrapePerformerSuggest } from \"../../select/ScrapePerformerSuggest\";\nimport { DetailsEditNavbar } from \"../../Shared/DetailsEditNavbar\";\nimport { ToastUtils } from \"../../../utils/toasts\";\nimport { EditableTextUtils } from \"../../../utils/editabletext\";\nimport { ImageUtils } from \"../../../utils/image\";\n\ninterface IPerformerProps extends IBaseProps {}\n\nexport const Performer: React.FC<IPerformerProps> = (props: IPerformerProps) => {\n  const isNew = props.match.params.id === \"new\";\n\n  // Editing state\n  const [isEditing, setIsEditing] = useState<boolean>(isNew);\n  const [isDisplayingScraperDialog, setIsDisplayingScraperDialog] = useState<GQL.ListPerformerScrapersListPerformerScrapers | undefined>(undefined);\n  const [scrapePerformerDetails, setScrapePerformerDetails] = useState<GQL.ScrapePerformerListScrapePerformerList | undefined>(undefined);\n\n  // Editing performer state\n  const [image, setImage] = useState<string | undefined>(undefined);\n  const [name, setName] = useState<string | undefined>(undefined);\n  const [aliases, setAliases] = useState<string | undefined>(undefined);\n  const [favorite, setFavorite] = useState<boolean | undefined>(undefined);\n  const [birthdate, setBirthdate] = useState<string | undefined>(undefined);\n  const [ethnicity, setEthnicity] = useState<string | undefined>(undefined);\n  const [country, setCountry] = useState<string | undefined>(undefined);\n  const [eyeColor, setEyeColor] = useState<string | undefined>(undefined);\n  const [height, setHeight] = useState<string | undefined>(undefined);\n  const [measurements, setMeasurements] = useState<string | undefined>(undefined);\n  const [fakeTits, setFakeTits] = useState<string | undefined>(undefined);\n  const [careerLength, setCareerLength] = useState<string | undefined>(undefined);\n  const [tattoos, setTattoos] = useState<string | undefined>(undefined);\n  const [piercings, setPiercings] = useState<string | undefined>(undefined);\n  const [url, setUrl] = useState<string | undefined>(undefined);\n  const [twitter, setTwitter] = useState<string | undefined>(undefined);\n  const [instagram, setInstagram] = useState<string | undefined>(undefined);\n\n  // Performer state\n  const [performer, setPerformer] = useState<Partial<GQL.PerformerDataFragment>>({});\n  const [imagePreview, setImagePreview] = useState<string | undefined>(undefined);\n\n  // Network state\n  const [isLoading, setIsLoading] = useState(false);\n\n  const Scrapers = StashService.useListPerformerScrapers();\n  const [queryableScrapers, setQueryableScrapers] = useState<GQL.ListPerformerScrapersListPerformerScrapers[]>([]);\n\n  const { data, error, loading } = StashService.useFindPerformer(props.match.params.id);\n  const updatePerformer = StashService.usePerformerUpdate(getPerformerInput() as GQL.PerformerUpdateInput);\n  const createPerformer = StashService.usePerformerCreate(getPerformerInput() as GQL.PerformerCreateInput);\n  const deletePerformer = StashService.usePerformerDestroy(getPerformerInput() as GQL.PerformerDestroyInput);\n\n  function updatePerformerEditState(state: Partial<GQL.PerformerDataFragment | GQL.ScrapeFreeonesScrapeFreeones>) {\n    if ((state as GQL.PerformerDataFragment).favorite !== undefined) {\n      setFavorite((state as GQL.PerformerDataFragment).favorite);\n    }\n    setName(state.name);\n    setAliases(state.aliases);\n    setBirthdate(state.birthdate);\n    setEthnicity(state.ethnicity);\n    setCountry(state.country);\n    setEyeColor(state.eye_color);\n    setHeight(state.height);\n    setMeasurements(state.measurements);\n    setFakeTits(state.fake_tits);\n    setCareerLength(state.career_length);\n    setTattoos(state.tattoos);\n    setPiercings(state.piercings);\n    setUrl(state.url);\n    setTwitter(state.twitter);\n    setInstagram(state.instagram);\n  }\n\n  useEffect(() => {\n    setIsLoading(loading);\n    if (!data || !data.findPerformer || !!error) { return; }\n    setPerformer(data.findPerformer);\n  }, [data]);\n\n  useEffect(() => {\n    setImagePreview(performer.image_path);\n    setImage(undefined);\n    updatePerformerEditState(performer);\n    if (!isNew) {\n      setIsEditing(false);\n    }\n  }, [performer]);\n\n  function onImageLoad(this: FileReader) {\n    setImagePreview(this.result as string);\n    setImage(this.result as string);\n  }\n\n  ImageUtils.addPasteImageHook(onImageLoad);\n  \n  useEffect(() => {\n    var newQueryableScrapers : GQL.ListPerformerScrapersListPerformerScrapers[] = [];\n\n    if (!!Scrapers.data && Scrapers.data.listPerformerScrapers) {\n      newQueryableScrapers = Scrapers.data.listPerformerScrapers.filter((s) => {\n        return s.performer && s.performer.supported_scrapes.includes(GQL.ScrapeType.Name);\n      });\n    }\n\n    setQueryableScrapers(newQueryableScrapers);\n\n  }, [Scrapers.data]);\n\n  if ((!isNew && !isEditing && (!data || !data.findPerformer)) || isLoading) {\n    return <Spinner animation=\"border\" variant=\"light\" />; \n  }\n  if (!!error) { return <>error...</>; }\n\n  function getPerformerInput() {\n    const performerInput: Partial<GQL.PerformerCreateInput | GQL.PerformerUpdateInput> = {\n      name,\n      aliases,\n      favorite,\n      birthdate,\n      ethnicity,\n      country,\n      eye_color: eyeColor,\n      height,\n      measurements,\n      fake_tits: fakeTits,\n      career_length: careerLength,\n      tattoos,\n      piercings,\n      url,\n      twitter,\n      instagram,\n      image,\n    };\n\n    if (!isNew) {\n      (performerInput as GQL.PerformerUpdateInput).id = props.match.params.id;\n    }\n    return performerInput;\n  }\n\n  async function onSave() {\n    setIsLoading(true);\n    try {\n      if (!isNew) {\n        const result = await updatePerformer();\n        setPerformer(result.data.performerUpdate);\n      } else {\n        const result = await createPerformer();\n        setPerformer(result.data.performerCreate);\n        props.history.push(`/performers/${result.data.performerCreate.id}`);\n      }\n    } catch (e) {\n      ErrorUtils.handle(e);\n    }\n    setIsLoading(false);\n  }\n\n  async function onDelete() {\n    setIsLoading(true);\n    try {\n      await deletePerformer();\n    } catch (e) {\n      ErrorUtils.handle(e);\n    }\n    setIsLoading(false);\n    \n    // redirect to performers page\n    props.history.push(`/performers`);\n  }\n\n  async function onAutoTag() {\n    if (!performer || !performer.id) {\n      return;\n    }\n    try {\n      await StashService.queryMetadataAutoTag({ performers: [performer.id]});\n      ToastUtils.success(\"Started auto tagging\");\n    } catch (e) {\n      ErrorUtils.handle(e);\n    }\n  }\n\n  function onImageChange(event: React.FormEvent<HTMLInputElement>) {\n    ImageUtils.onImageChange(event, onImageLoad);\n  }\n\n  function onDisplayFreeOnesDialog(scraper: GQL.ListPerformerScrapersListPerformerScrapers) {\n    setIsDisplayingScraperDialog(scraper);\n  }\n\n  function getQueryScraperPerformerInput() {\n    if (!scrapePerformerDetails) {\n      return {};\n    }\n\n    let ret = _.clone(scrapePerformerDetails);\n    delete ret.__typename;\n    return ret as GQL.ScrapedPerformerInput;\n  }\n\n  async function onScrapePerformer() {\n    setIsDisplayingScraperDialog(undefined);\n    setIsLoading(true);\n    try {\n      if (!scrapePerformerDetails || !isDisplayingScraperDialog) { return; }\n      const result = await StashService.queryScrapePerformer(isDisplayingScraperDialog.id, getQueryScraperPerformerInput());\n      if (!result.data || !result.data.scrapePerformer) { return; }\n      updatePerformerEditState(result.data.scrapePerformer);\n    } catch (e) {\n      ErrorUtils.handle(e);\n    }\n    setIsLoading(false);\n  }\n\n  async function onScrapePerformerURL() {\n    if (!url) { return; }\n    setIsLoading(true);\n    try {\n      const result = await StashService.queryScrapePerformerURL(url);\n      if (!result.data || !result.data.scrapePerformerURL) { return; }\n      updatePerformerEditState(result.data.scrapePerformerURL);\n    } catch (e) {\n      ErrorUtils.handle(e);\n    } finally {\n      setIsLoading(false);\n    }\n  }\n\n  function renderEthnicity() {\n    return TableUtils.renderHtmlSelect({\n      title: \"Ethnicity\",\n      value: ethnicity,\n      isEditing,\n      onChange: (value: string) => setEthnicity(value),\n      selectOptions: [\"white\", \"black\", \"asian\", \"hispanic\"],\n    });\n  }\n\n  function renderScraperDialog() {\n    return (\n      <Modal\n        show={!!isDisplayingScraperDialog}\n        onHide={() => setIsDisplayingScraperDialog(undefined)}\n      >\n        <Modal.Header>\n          Scrape\n        </Modal.Header>\n        <Modal.Body>\n          <div className=\"dialog-content\">\n            <ScrapePerformerSuggest\n              placeholder=\"Performer name\"\n              style={{width: \"100%\"}}\n              scraperId={isDisplayingScraperDialog ? isDisplayingScraperDialog.id : \"\"}\n              onSelectPerformer={(query) => setScrapePerformerDetails(query)}\n            />\n          </div>\n        </Modal.Body>\n        <Modal.Footer>\n          <Button onClick={() => onScrapePerformer()}>Scrape</Button>\n        </Modal.Footer>\n      </Modal>\n    );\n  }\n\n  function urlScrapable(url: string) : boolean {\n    return !!url && !!Scrapers.data && Scrapers.data.listPerformerScrapers && Scrapers.data.listPerformerScrapers.some((s) => {\n      return !!s.performer && !!s.performer.urls && s.performer.urls.some((u) => { return url.includes(u); });\n    });\n  }\n\n  function maybeRenderScrapeButton() {\n    if (!url || !isEditing || !urlScrapable(url)) {\n      return undefined;\n    }\n    return (\n      <Button \n        id=\"scrape-url-button\"\n        onClick={() => onScrapePerformerURL()}>\n        <FontAwesomeIcon icon=\"file-upload\" />\n      </Button>\n    )\n  }\n\n  function renderURLField() {\n    return (\n      <tr>\n        <td id=\"url-field\">\n          URL \n          {maybeRenderScrapeButton()}\n        </td>\n        <td>\n          {EditableTextUtils.renderInputGroup({\n            value: url, isEditing, onChange: setUrl, placeholder: \"URL\"\n          })}\n        </td>\n      </tr>\n    );\n  }\n\n  return (\n    <>\n      {renderScraperDialog()}\n      <div className=\"row is-multiline no-spacing\">\n        <div className=\"col-6 details-image-container\">\n          <img className=\"performer\" alt=\"\" src={imagePreview} />\n        </div>\n        <div className=\"col-6 details-detail-container\">\n          <DetailsEditNavbar\n            performer={performer}\n            isNew={isNew}\n            isEditing={isEditing}\n            onToggleEdit={() => { setIsEditing(!isEditing); updatePerformerEditState(performer); }}\n            onSave={onSave}\n            onDelete={onDelete}\n            onImageChange={onImageChange}\n            scrapers={queryableScrapers}\n            onDisplayScraperDialog={onDisplayFreeOnesDialog}\n            onAutoTag={onAutoTag}\n          />\n          <h1>\n            { !isEditing\n                ? <span>{name}</span>\n                : <Form.Control\n                    defaultValue={name}\n                    placeholder=\"Name\"\n                    onChange={(event: any) => setName(event.target.value)} />\n            }\n          </h1>\n          <h6>\n            <Form.Group className=\"aliases-field\" controlId=\"aliases\">\n              <Form.Label>Aliases:</Form.Label>\n              {EditableTextUtils.renderInputGroup({\n                value: aliases, isEditing: isEditing, placeholder: \"Aliases\", onChange: setAliases\n              })}\n            </Form.Group>\n          </h6>\n          <div>\n            <span style={{fontWeight: 300}}>Favorite:</span>\n            <Button\n              disabled={!isEditing}\n              className={favorite ? \"favorite\" : undefined}\n              onClick={() => setFavorite(!favorite)}\n            >\n              <FontAwesomeIcon icon=\"heart\" />\n            </Button>\n          </div>\n\n          <Table id=\"performer-details\" style={{width: \"100%\"}}>\n            <tbody>\n              {TableUtils.renderInputGroup(\n                {title: \"Birthdate (YYYY-MM-DD)\", value: birthdate, isEditing, onChange: setBirthdate})}\n              {renderEthnicity()}\n              {TableUtils.renderInputGroup(\n                {title: \"Eye Color\", value: eyeColor, isEditing, onChange: setEyeColor})}\n              {TableUtils.renderInputGroup(\n                {title: \"Country\", value: country, isEditing, onChange: setCountry})}\n              {TableUtils.renderInputGroup(\n                {title: \"Height (CM)\", value: height, isEditing, onChange: setHeight})}\n              {TableUtils.renderInputGroup(\n                {title: \"Measurements\", value: measurements, isEditing, onChange: setMeasurements})}\n              {TableUtils.renderInputGroup(\n                {title: \"Fake Tits\", value: fakeTits, isEditing, onChange: setFakeTits})}\n              {TableUtils.renderInputGroup(\n                {title: \"Career Length\", value: careerLength, isEditing, onChange: setCareerLength})}\n              {TableUtils.renderInputGroup(\n                {title: \"Tattoos\", value: tattoos, isEditing, onChange: setTattoos})}\n              {TableUtils.renderInputGroup(\n                {title: \"Piercings\", value: piercings, isEditing, onChange: setPiercings})}\n              {renderURLField()}\n              {TableUtils.renderInputGroup(\n                {title: \"Twitter\", value: twitter, isEditing, onChange: setTwitter})}\n              {TableUtils.renderInputGroup(\n                {title: \"Instagram\", value: instagram, isEditing, onChange: setInstagram})}\n            </tbody>\n          </Table>\n        </div>\n      </div>\n    </>\n  );\n};\n","/home/peroo/stash/ui/v2.5/src/components/performers/PerformerList.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/performers/PerformerListTable.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/performers/performers.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/scenes/SceneCard.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/scenes/SceneDetails/Scene.tsx",["395","396"],"import { Card, Spinner, Tab, Tabs } from 'react-bootstrap';\nimport queryString from \"query-string\";\nimport React, { FunctionComponent, useEffect, useState } from \"react\";\nimport * as GQL from \"../../../core/generated-graphql\";\nimport { StashService } from \"../../../core/StashService\";\nimport { IBaseProps } from \"../../../models\";\nimport { GalleryViewer } from \"../../Galleries/GalleryViewer\";\nimport { ScenePlayer } from \"../ScenePlayer/ScenePlayer\";\nimport { SceneDetailPanel } from \"./SceneDetailPanel\";\nimport { SceneEditPanel } from \"./SceneEditPanel\";\nimport { SceneFileInfoPanel } from \"./SceneFileInfoPanel\";\nimport { SceneMarkersPanel } from \"./SceneMarkersPanel\";\nimport { ScenePerformerPanel } from \"./ScenePerformerPanel\";\n\ninterface ISceneProps extends IBaseProps {}\n\nexport const Scene: FunctionComponent<ISceneProps> = (props: ISceneProps) => {\n  const [timestamp, setTimestamp] = useState<number>(0);\n  const [autoplay, setAutoplay] = useState<boolean>(false);\n  const [scene, setScene] = useState<Partial<GQL.SceneDataFragment>>({});\n  const [isLoading, setIsLoading] = useState(false);\n  const { data, error, loading } = StashService.useFindScene(props.match.params.id);\n\n  useEffect(() => {\n    setIsLoading(loading);\n    if (!data || !data.findScene || !!error) { return; }\n    setScene(StashService.nullToUndefined(data.findScene));\n  }, [data]);\n\n  useEffect(() => {\n    const queryParams = queryString.parse(props.location.search);\n    if (!!queryParams.t && typeof queryParams.t === \"string\" && timestamp === 0) {\n      const newTimestamp = parseInt(queryParams.t, 10);\n      setTimestamp(newTimestamp);\n    }\n    if (queryParams.autoplay && typeof queryParams.autoplay === \"string\") {\n      setAutoplay(queryParams.autoplay === \"true\");\n    }\n  });\n\n  function onClickMarker(marker: GQL.SceneMarkerDataFragment) {\n    setTimestamp(marker.seconds);\n  }\n\n  if (!data || !data.findScene || isLoading || Object.keys(scene).length === 0) {\n    return <Spinner animation=\"border\"/>;\n  }\n  const modifiedScene =\n    Object.assign({scene_marker_tags: data.sceneMarkerTags}, scene) as GQL.SceneDataFragment; // TODO Hack from angular\n  if (!!error) { return <>error...</>; }\n\n  return (\n    <>\n      <ScenePlayer scene={modifiedScene} timestamp={timestamp} autoplay={autoplay}/>\n      <Card id=\"details-container\">\n        <Tabs id=\"scene-tabs\" mountOnEnter={true}>\n            <Tab eventKey=\"scene-details-panel\" title=\"Details\">\n              <SceneDetailPanel scene={modifiedScene} />\n            </Tab>\n            <Tab\n              eventKey=\"scene-markers-panel\"\n              title=\"Markers\">\n              <SceneMarkersPanel scene={modifiedScene} onClickMarker={onClickMarker} />\n            </Tab>\n            {modifiedScene.performers.length > 0 ?\n              <Tab\n                eventKey=\"scene-performer-panel\"\n                title=\"Performers\">\n                <ScenePerformerPanel scene={modifiedScene} />\n              </Tab> : ''\n            }\n            {!!modifiedScene.gallery ?\n              <Tab\n                eventKey=\"scene-gallery-panel\"\n                title=\"Gallery\">\n                <GalleryViewer gallery={modifiedScene.gallery} />\n              </Tab> : ''\n            }\n            <Tab eventKey=\"scene-file-info-panel\" title=\"File Info\">\n                <SceneFileInfoPanel scene={modifiedScene} />\n            </Tab>\n            <Tab\n              eventKey=\"scene-edit-panel\"\n              title=\"Edit\">\n              <SceneEditPanel \n                scene={modifiedScene} \n                onUpdate={(newScene) => setScene(newScene)} \n                onDelete={() => props.history.push(\"/scenes\")}\n              />\n            </Tab>\n        </Tabs>\n      </Card>\n    </>\n  );\n};\n","/home/peroo/stash/ui/v2.5/src/components/scenes/SceneDetails/SceneDetailPanel.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/scenes/SceneDetails/SceneEditPanel.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/scenes/SceneDetails/SceneFileInfoPanel.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/scenes/SceneDetails/SceneMarkersPanel.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/scenes/SceneDetails/ScenePerformerPanel.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/scenes/SceneFilenameParser.tsx",["397","398"],"import { Badge, Button, Card, Collapse, Dropdown, DropdownButton, Form, Table, Spinner } from 'react-bootstrap';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport React, { useEffect, useState } from \"react\";\nimport { StashService } from \"../../core/StashService\";\nimport * as GQL from \"../../core/generated-graphql\";\nimport { SlimSceneDataFragment, Maybe } from \"../../core/generated-graphql\";\nimport { TextUtils } from \"../../utils/text\";\nimport _ from \"lodash\";\nimport { ToastUtils } from \"../../utils/toasts\";\nimport { ErrorUtils } from \"../../utils/errors\";\nimport { Pagination } from \"../list/Pagination\";\nimport { FilterSelect, StudioSelect } from \"../select/FilterSelect\";\n  \nclass ParserResult<T> {\n  public value: Maybe<T>;\n  public originalValue: Maybe<T>;\n  public set: boolean = false;\n\n  public setOriginalValue(v : Maybe<T>) {\n    this.originalValue = v;\n    this.value = v;\n  }\n\n  public setValue(v : Maybe<T>) {\n    if (!!v) {\n      this.value = v;\n      this.set = !_.isEqual(this.value, this.originalValue);\n    }\n  }\n}\n\nclass ParserField {\n  public field : string;\n  public helperText? : string;\n\n  constructor(field: string, helperText?: string) {\n    this.field = field;\n    this.helperText = helperText;\n  }\n\n  public getFieldPattern() {\n    return \"{\" + this.field + \"}\";\n  }\n\n  static Title = new ParserField(\"title\");\n  static Ext = new ParserField(\"ext\", \"File extension\");\n\n  static I = new ParserField(\"i\", \"Matches any ignored word\");\n  static D = new ParserField(\"d\", \"Matches any delimiter (.-_)\");\n\n  static Performer = new ParserField(\"performer\");\n  static Studio = new ParserField(\"studio\");\n  static Tag = new ParserField(\"tag\");\n\n  // date fields\n  static Date = new ParserField(\"date\", \"YYYY-MM-DD\");\n  static YYYY = new ParserField(\"yyyy\", \"Year\");\n  static YY = new ParserField(\"yy\", \"Year (20YY)\");\n  static MM = new ParserField(\"mm\", \"Two digit month\");\n  static DD = new ParserField(\"dd\", \"Two digit date\");\n  static YYYYMMDD = new ParserField(\"yyyymmdd\");\n  static YYMMDD = new ParserField(\"yymmdd\");\n  static DDMMYYYY = new ParserField(\"ddmmyyyy\");\n  static DDMMYY = new ParserField(\"ddmmyy\");\n  static MMDDYYYY = new ParserField(\"mmddyyyy\");\n  static MMDDYY = new ParserField(\"mmddyy\");\n\n  static validFields = [\n    ParserField.Title,\n    ParserField.Ext,\n    ParserField.D,\n    ParserField.I,\n    ParserField.Performer,\n    ParserField.Studio,\n    ParserField.Tag,\n    ParserField.Date,\n    ParserField.YYYY,\n    ParserField.YY,\n    ParserField.MM,\n    ParserField.DD,\n    ParserField.YYYYMMDD,\n    ParserField.YYMMDD,\n    ParserField.DDMMYYYY,\n    ParserField.DDMMYY,\n    ParserField.MMDDYYYY,\n    ParserField.MMDDYY\n  ]\n\n  static fullDateFields = [\n    ParserField.YYYYMMDD,\n    ParserField.YYMMDD,\n    ParserField.DDMMYYYY,\n    ParserField.DDMMYY,\n    ParserField.MMDDYYYY,\n    ParserField.MMDDYY\n  ];\n}\nclass SceneParserResult {\n  public id: string;\n  public filename: string;\n  public title: ParserResult<string> = new ParserResult();\n  public date: ParserResult<string> = new ParserResult();\n\n  public studio: ParserResult<GQL.SlimSceneDataStudio> = new ParserResult();\n  public studioId: ParserResult<string> = new ParserResult();\n  public tags: ParserResult<GQL.SlimSceneDataTags[]> = new ParserResult();\n  public tagIds: ParserResult<string[]> = new ParserResult();\n  public performers: ParserResult<GQL.SlimSceneDataPerformers[]> = new ParserResult();\n  public performerIds: ParserResult<string[]> = new ParserResult();\n\n  public scene : SlimSceneDataFragment;\n\n  constructor(result : GQL.ParseSceneFilenamesResults) {\n    this.scene = result.scene;\n\n    this.id = this.scene.id;\n    this.filename = TextUtils.fileNameFromPath(this.scene.path);\n    this.title.setOriginalValue(this.scene.title);\n    this.date.setOriginalValue(this.scene.date);\n    this.performerIds.setOriginalValue(this.scene.performers.map((p) => p.id));\n    this.performers.setOriginalValue(this.scene.performers);\n    this.tagIds.setOriginalValue(this.scene.tags.map((t) => t.id));\n    this.tags.setOriginalValue(this.scene.tags);\n    this.studioId.setOriginalValue(this.scene.studio ? this.scene.studio.id : undefined);\n    this.studio.setOriginalValue(this.scene.studio);\n\n    this.title.setValue(result.title);\n    this.date.setValue(result.date);\n    this.performerIds.setValue(result.performer_ids);\n    this.tagIds.setValue(result.tag_ids);\n    this.studioId.setValue(result.studio_id);\n\n    if (result.performer_ids) {\n      this.performers.setValue(result.performer_ids.map((p) => {\n        return {\n          id: p,\n          name: \"\",\n          favorite: false,\n          image_path: \"\"\n        };\n      }));\n    }\n\n    if (result.tag_ids) {\n      this.tags.setValue(result.tag_ids.map((t) => {\n        return {\n          id: t,\n          name: \"\",\n        };\n      }));\n    }\n\n    if (result.studio_id) {\n      this.studio.setValue({\n        id: result.studio_id,\n        name: \"\",\n        image_path: \"\"\n      });\n    }\n  }\n\n  private static setInput(object: any, key: string, parserResult : ParserResult<any>) {\n    if (parserResult.set) {\n      object[key] = parserResult.value;\n    }\n  }\n\n  // returns true if any of its fields have set == true\n  public isChanged() {\n    return this.title.set || this.date.set || this.performerIds.set || this.studioId.set || this.tagIds.set;\n  }\n\n  public toSceneUpdateInput() {\n    var ret = {\n      id: this.id,\n      title: this.scene.title,\n      details: this.scene.details,\n      url: this.scene.url,\n      date: this.scene.date,\n      rating: this.scene.rating,\n      gallery_id: this.scene.gallery ? this.scene.gallery.id : undefined,\n      studio_id: this.scene.studio ? this.scene.studio.id : undefined,\n      performer_ids: this.scene.performers.map((performer) => performer.id),\n      tag_ids: this.scene.tags.map((tag) => tag.id)\n    };\n\n    SceneParserResult.setInput(ret, \"title\", this.title);\n    SceneParserResult.setInput(ret, \"date\", this.date);\n    SceneParserResult.setInput(ret, \"performer_ids\", this.performerIds);\n    SceneParserResult.setInput(ret, \"studio_id\", this.studioId);\n    SceneParserResult.setInput(ret, \"tag_ids\", this.tagIds);\n\n    return ret;\n  }\n};\n\ninterface IParserInput {\n  pattern: string,\n  ignoreWords: string[],\n  whitespaceCharacters: string,\n  capitalizeTitle: boolean,\n  page: number,\n  pageSize: number,\n  findClicked: boolean\n}\n\ninterface IParserRecipe {\n  pattern: string,\n  ignoreWords: string[],\n  whitespaceCharacters: string,\n  capitalizeTitle: boolean,\n  description: string\n}\n\nconst builtInRecipes = [\n  {\n    pattern: \"{title}\",\n    ignoreWords: [],\n    whitespaceCharacters: \"\",\n    capitalizeTitle: false,\n    description: \"Filename\"\n  },\n  {\n    pattern: \"{title}.{ext}\",\n    ignoreWords: [],\n    whitespaceCharacters: \"\",\n    capitalizeTitle: false,\n    description: \"Without extension\"\n  },\n  {\n    pattern: \"{}.{yy}.{mm}.{dd}.{title}.XXX.{}.{ext}\",\n    ignoreWords: [],\n    whitespaceCharacters: \".\",\n    capitalizeTitle: true,\n    description: \"\"\n  },\n  {\n    pattern: \"{}.{yy}.{mm}.{dd}.{title}.{ext}\",\n    ignoreWords: [],\n    whitespaceCharacters: \".\",\n    capitalizeTitle: true,\n    description: \"\"\n  },\n  {\n    pattern: \"{title}.XXX.{}.{ext}\",\n    ignoreWords: [],\n    whitespaceCharacters: \".\",\n    capitalizeTitle: true,\n    description: \"\"\n  },\n  {\n    pattern: \"{}.{yy}.{mm}.{dd}.{title}.{i}.{ext}\",\n    ignoreWords: [\"cz\", \"fr\"],\n    whitespaceCharacters: \".\",\n    capitalizeTitle: true,\n    description: \"Foreign language\"\n  }\n];\n\nexport const SceneFilenameParser: React.FC = () => {\n  const [parserResult, setParserResult] = useState<SceneParserResult[]>([]);\n  const [parserInput, setParserInput] = useState<IParserInput>(initialParserInput());\n\n  const [allTitleSet, setAllTitleSet] = useState<boolean>(false);\n  const [allDateSet, setAllDateSet] = useState<boolean>(false);\n  const [allPerformerSet, setAllPerformerSet] = useState<boolean>(false);\n  const [allTagSet, setAllTagSet] = useState<boolean>(false);\n  const [allStudioSet, setAllStudioSet] = useState<boolean>(false);\n\n  const [showFields, setShowFields] = useState<Map<string, boolean>>(initialShowFieldsState());\n  \n  const [totalItems, setTotalItems] = useState<number>(0);\n\n  // Network state\n  const [isLoading, setIsLoading] = useState(false);\n\n  const updateScenes = StashService.useScenesUpdate(getScenesUpdateData());\n\n  function initialParserInput() {\n    return {\n      pattern: \"{title}.{ext}\",\n      ignoreWords: [],\n      whitespaceCharacters: \"._\",\n      capitalizeTitle: true,\n      page: 1,\n      pageSize: 20,\n      findClicked: false\n    };\n  }\n\n  function initialShowFieldsState() {\n    return new Map<string, boolean>([\n      [\"Title\", true],\n      [\"Date\", true],\n      [\"Performers\", true],\n      [\"Tags\", true],\n      [\"Studio\", true]\n    ]);\n  }\n\n  function getParserFilter() {\n    return {\n      q: parserInput.pattern,\n      page: parserInput.page,\n      per_page: parserInput.pageSize,\n      sort: \"path\",\n      direction: GQL.SortDirectionEnum.Asc,\n    };\n  }\n\n  function getParserInput() {\n    return {\n      ignoreWords: parserInput.ignoreWords,\n      whitespaceCharacters: parserInput.whitespaceCharacters,\n      capitalizeTitle: parserInput.capitalizeTitle\n    };\n  }\n\n  async function onFind() {\n    setParserResult([]);\n\n    setIsLoading(true);\n    \n    try {\n      const response = await StashService.queryParseSceneFilenames(getParserFilter(), getParserInput());\n\n      let result = response.data.parseSceneFilenames;\n      if (!!result) {\n        parseResults(result.results);\n        setTotalItems(result.count);\n      }\n    } catch (err) {\n      ErrorUtils.handle(err);\n    }\n\n    setIsLoading(false);\n  }\n\n  useEffect(() => {\n    if(parserInput.findClicked) {\n      onFind();\n    }\n  }, [parserInput]);\n\n  function onPageSizeChanged(newSize : number) {\n    var newInput = _.clone(parserInput);\n    newInput.page = 1;\n    newInput.pageSize = newSize;\n    setParserInput(newInput);\n  }\n\n  function onPageChanged(newPage : number) {\n    if (newPage !== parserInput.page) {\n      var newInput = _.clone(parserInput);\n      newInput.page = newPage;\n      setParserInput(newInput);\n    }\n  }\n\n  function onFindClicked(input : IParserInput) {\n    input.page = 1;\n    input.findClicked = true;\n    setParserInput(input);\n    setTotalItems(0);\n  }\n\n  function getScenesUpdateData() {\n    return parserResult.filter((result) => result.isChanged()).map((result) => result.toSceneUpdateInput());\n  }\n\n  async function onApply() {\n    setIsLoading(true);\n\n    try {\n      await updateScenes();\n      ToastUtils.success(\"Updated scenes\");\n    } catch (e) {\n      ErrorUtils.handle(e);\n    }\n\n    setIsLoading(false);\n  }\n\n  function parseResults(results : GQL.ParseSceneFilenamesResults[]) {\n    if (results) {\n      var result = results.map((r) => {\n        return new SceneParserResult(r);\n      }).filter((r) => !!r) as SceneParserResult[];\n\n      setParserResult(result);\n      determineFieldsToHide();\n    }\n  }\n\n  function determineFieldsToHide() {\n    var pattern = parserInput.pattern;\n    var titleSet = pattern.includes(\"{title}\");\n    var dateSet = pattern.includes(\"{date}\") || \n      pattern.includes(\"{dd}\") || // don't worry about other partial date fields since this should be implied\n      ParserField.fullDateFields.some((f) => {\n        return pattern.includes(\"{\" + f.field + \"}\");\n      });\n    var performerSet = pattern.includes(\"{performer}\");\n    var tagSet = pattern.includes(\"{tag}\");\n    var studioSet = pattern.includes(\"{studio}\");\n\n    var showFieldsCopy = _.clone(showFields);\n    showFieldsCopy.set(\"Title\", titleSet);\n    showFieldsCopy.set(\"Date\", dateSet);\n    showFieldsCopy.set(\"Performers\", performerSet);\n    showFieldsCopy.set(\"Tags\", tagSet);\n    showFieldsCopy.set(\"Studio\", studioSet);\n    setShowFields(showFieldsCopy);\n  }\n\n  useEffect(() => {\n    var newAllTitleSet = !parserResult.some((r) => {\n      return !r.title.set;\n    });\n    var newAllDateSet = !parserResult.some((r) => {\n      return !r.date.set;\n    });\n    var newAllPerformerSet = !parserResult.some((r) => {\n      return !r.performerIds.set;\n    });\n    var newAllTagSet = !parserResult.some((r) => {\n      return !r.tagIds.set;\n    });\n    var newAllStudioSet = !parserResult.some((r) => {\n      return !r.studioId.set;\n    });\n\n    if (newAllTitleSet !== allTitleSet) {\n      setAllTitleSet(newAllTitleSet);\n    }\n    if (newAllDateSet !== allDateSet) {\n      setAllDateSet(newAllDateSet);\n    }\n    if (newAllPerformerSet !== allPerformerSet) {\n      setAllTagSet(newAllPerformerSet);\n    }\n    if (newAllTagSet !== allTagSet) {\n      setAllTagSet(newAllTagSet);\n    }\n    if (newAllStudioSet !== allStudioSet) {\n      setAllStudioSet(newAllStudioSet);\n    }\n  }, [parserResult]);\n\n  function onSelectAllTitleSet(selected : boolean) {\n    var newResult = [...parserResult];\n\n    newResult.forEach((r) => {\n      r.title.set = selected;\n    });\n\n    setParserResult(newResult);\n    setAllTitleSet(selected);\n  }\n\n  function onSelectAllDateSet(selected : boolean) {\n    var newResult = [...parserResult];\n\n    newResult.forEach((r) => {\n      r.date.set = selected;\n    });\n\n    setParserResult(newResult);\n    setAllDateSet(selected);\n  }\n\n  function onSelectAllPerformerSet(selected : boolean) {\n    var newResult = [...parserResult];\n\n    newResult.forEach((r) => {\n      r.performerIds.set = selected;\n    });\n\n    setParserResult(newResult);\n    setAllPerformerSet(selected);\n  }\n\n  function onSelectAllTagSet(selected : boolean) {\n    var newResult = [...parserResult];\n\n    newResult.forEach((r) => {\n      r.tagIds.set = selected;\n    });\n\n    setParserResult(newResult);\n    setAllTagSet(selected);\n  }\n\n  function onSelectAllStudioSet(selected : boolean) {\n    var newResult = [...parserResult];\n\n    newResult.forEach((r) => {\n      r.studioId.set = selected;\n    });\n\n    setParserResult(newResult);\n    setAllStudioSet(selected);\n  }\n\n  interface IShowFieldsProps {\n    fields: Map<string, boolean>\n    onShowFieldsChanged: (fields : Map<string, boolean>) => void\n  }\n\n  function ShowFields(props: IShowFieldsProps) {\n    const [open, setOpen] = useState(false);\n\n    function handleClick(label: string) {\n      const copy = new Map<string, boolean>(props.fields);\n      copy.set(label, !props.fields.get(label));\n      props.onShowFieldsChanged(copy);\n    }\n\n    const fieldRows = [...props.fields.entries()].map(([label, enabled]) => (\n      <div key={label} onClick={() => {handleClick(label)}}>\n        <FontAwesomeIcon icon={enabled ? \"check\" : \"times\" } />\n        <span>{label}</span>\n      </div>\n    ));\n\n    return (\n      <div>\n        <div onClick={() => setOpen(!open)}>\n          <FontAwesomeIcon icon={open ? \"chevron-down\" : \"chevron-right\" } />\n          <span>Display fields</span>\n        </div>\n        <Collapse in={open}>\n          <div>\n            {fieldRows}\n          </div>\n        </Collapse>\n      </div>\n    );\n  }\n\n  interface IParserInputProps {\n    input: IParserInput,\n    onFind: (input : IParserInput) => void\n  }\n\n  function ParserInput(props : IParserInputProps) {\n    const [pattern, setPattern] = useState<string>(props.input.pattern);\n    const [ignoreWords, setIgnoreWords] = useState<string>(props.input.ignoreWords.join(\" \"));\n    const [whitespaceCharacters, setWhitespaceCharacters] = useState<string>(props.input.whitespaceCharacters);\n    const [capitalizeTitle, setCapitalizeTitle] = useState<boolean>(props.input.capitalizeTitle);\n\n    function onFind() {\n      props.onFind({\n        pattern: pattern,\n        ignoreWords: ignoreWords.split(\" \"),\n        whitespaceCharacters: whitespaceCharacters,\n        capitalizeTitle: capitalizeTitle,\n        page: 1,\n        pageSize: props.input.pageSize,\n        findClicked: props.input.findClicked\n      });\n    }\n\n    function setParserRecipe(recipe: IParserRecipe) {\n      setPattern(recipe.pattern);\n      setIgnoreWords(recipe.ignoreWords.join(\" \"));\n      setWhitespaceCharacters(recipe.whitespaceCharacters);\n      setCapitalizeTitle(recipe.capitalizeTitle);\n    }\n  \n    const validFields = [new ParserField(\"\", \"Wildcard\")].concat(ParserField.validFields);\n    \n    function addParserField(field: ParserField) {\n      setPattern(pattern + field.getFieldPattern());\n    }\n\n    const PAGE_SIZE_OPTIONS = [\"20\", \"40\", \"60\", \"120\"];\n\n    return (\n      <Form.Group>\n      <Form.Group>\n        <Form.Control\n          onChange={(newValue: any) => setPattern(newValue.target.value)}\n          value={pattern}\n        />\n        <DropdownButton id=\"parser-field-select\" title=\"Add Field\">\n          { validFields.map(item => (\n            <Dropdown.Item onSelect={() => addParserField(item)}>\n              <span>{item.field}</span><span className=\"ml-auto\">{item.helperText}</span>\n            </Dropdown.Item>\n          ))}\n        </DropdownButton>\n        <div>Use '\\\\' to escape literal {} characters</div>\n      </Form.Group>\n\n      <Form.Group>\n        <Form.Label>Ignored words::</Form.Label>\n        <Form.Control\n          onChange={(newValue: any) => setIgnoreWords(newValue.target.value)}\n          value={ignoreWords}\n        />\n        <div>Matches with {\"{i}\"}</div>\n      </Form.Group>\n      \n      <Form.Group>\n        <h5>Title</h5>\n        <Form.Label>Whitespace characters:</Form.Label>\n        <Form.Control\n          onChange={(newValue: any) => setWhitespaceCharacters(newValue.target.value)}\n          value={whitespaceCharacters}\n        />\n        <Form.Group>\n          <Form.Label>Capitalize title</Form.Label>\n          <Form.Control\n            type=\"checkbox\"\n            checked={capitalizeTitle}\n            onChange={() => setCapitalizeTitle(!capitalizeTitle)}\n          />\n        </Form.Group>\n        <div>These characters will be replaced with whitespace in the title</div>\n      </Form.Group>\n          \n          {/* TODO - mapping stuff will go here */}\n\n          <Form.Group>\n            <DropdownButton id=\"recipe-select\" title=\"Select Parser Recipe\">\n              { builtInRecipes.map(item => (\n                <Dropdown.Item onSelect={() => setParserRecipe(item)}>\n                  <span>{item.pattern}</span><span className=\"mr-auto\">{item.description}</span>\n                </Dropdown.Item>\n              ))}\n            </DropdownButton>\n          </Form.Group>\n\n          <Form.Group>\n            <ShowFields\n              fields={showFields}\n              onShowFieldsChanged={(fields) => setShowFields(fields)}\n            />\n          </Form.Group>\n\n          <Form.Group>\n            <Button onClick={onFind}>Find</Button>\n            <Form.Control\n              as=\"select\"\n              style={{flexBasis: \"min-content\"}}\n              options={PAGE_SIZE_OPTIONS}\n              onChange={(event: any) => onPageSizeChanged(parseInt(event.target.value))}\n              defaultValue={props.input.pageSize}\n              className=\"filter-item\"\n            >\n              { PAGE_SIZE_OPTIONS.map(val => <option value=\"val\">{val}</option>) }\n            </Form.Control>\n          </Form.Group>\n        </Form.Group>\n    );\n  }\n\n  interface ISceneParserFieldProps {\n    parserResult : ParserResult<any>\n    className? : string\n    fieldName : string\n    onSetChanged : (set : boolean) => void\n    onValueChanged : (value : any) => void\n    originalParserResult? : ParserResult<any>\n    renderOriginalInputField: (props : ISceneParserFieldProps) => JSX.Element\n    renderNewInputField: (props : ISceneParserFieldProps, onChange : (event : any) => void) => JSX.Element\n  }\n\n  function SceneParserField(props : ISceneParserFieldProps) {\n\n    function maybeValueChanged(value : any) {\n      if (value !== props.parserResult.value) {\n        props.onValueChanged(value);\n      }\n    }\n\n    if (!showFields.get(props.fieldName)) {\n      return null;\n    }\n\n    return (\n      <>\n        <td>\n          <Form.Control\n            type=\"checkbox\"\n            checked={props.parserResult.set}\n            onChange={() => {props.onSetChanged(!props.parserResult.set)}}\n          />\n        </td>\n        <td>\n          <Form.Group>\n            {props.renderOriginalInputField(props)}\n            {props.renderNewInputField(props, (value) => maybeValueChanged(value))}\n          </Form.Group>\n        </td>\n      </>\n    );\n  }\n\n  function renderOriginalInputGroup(props: ISceneParserFieldProps) {\n    var parserResult = props.originalParserResult || props.parserResult;\n\n    return (\n      <Form.Control\n        disabled\n        className={props.className}\n        defaultValue={parserResult.originalValue || \"\"}\n      />\n    );\n  }\n\n  interface IInputGroupWrapperProps {\n    parserResult: ParserResult<any>\n    onChange : (event : any) => void\n    className? : string\n  }\n\n  function InputGroupWrapper(props: IInputGroupWrapperProps) {\n    return (\n      <Form.Control\n        disabled={!props.parserResult.set}\n        className={props.className}\n        value={props.parserResult.value || \"\"}\n        onBlur={(event: any) => props.onChange(event.target.value)}\n      />\n    );\n  }\n  \n  function renderNewInputGroup(props : ISceneParserFieldProps, onChange : (value : any) => void) {\n    return (\n      <InputGroupWrapper\n        className={props.className}\n        onChange={(value : any) => {onChange(value)}}\n        parserResult={props.parserResult}\n      />\n    );\n  }\n\n  interface HasName {\n    name: string\n  }\n\n  function renderOriginalSelect(props : ISceneParserFieldProps) {\n    const parserResult = props.originalParserResult || props.parserResult;\n\n    const elements = parserResult.originalValue\n      ? Array.isArray(parserResult.originalValue)\n        ? parserResult.originalValue.map((el:HasName) => el.name)\n        : parserResult.originalValue.name\n      : [];\n\n    return (\n      <div>\n        { elements.map((name:string) => <Badge variant=\"secondary\">{name}</Badge>) }\n      </div>\n    );\n  }\n\n  function renderNewMultiSelect(type: \"performers\" | \"tags\", props : ISceneParserFieldProps, onChange : (value : any) => void) {\n    return (\n      <FilterSelect\n        className={props.className}\n        type={type}\n        isMulti={true}\n        onSelect={(items) => {\n          const ids = items.map((i) => i.id);\n          onChange(ids);\n        }}\n        initialIds={props.parserResult.value}\n      />\n    );\n  }\n\n  function renderNewPerformerSelect(props : ISceneParserFieldProps, onChange : (value : any) => void) {\n    return renderNewMultiSelect(\"performers\", props, onChange);\n  }\n\n  function renderNewTagSelect(props : ISceneParserFieldProps, onChange : (value : any) => void) {\n    return renderNewMultiSelect(\"tags\", props, onChange);\n  }\n\n  function renderNewStudioSelect(props : ISceneParserFieldProps, onChange : (value : any) => void) {\n    return (\n      <StudioSelect\n        noSelectionString=\"\"\n        className={props.className}\n        onSelect={(items) => onChange(items[0]?.id)}\n        initialIds={props.parserResult.value ? [props.parserResult.value] : []}\n      />\n    );\n  }\n\n  interface ISceneParserRowProps {\n    scene : SceneParserResult,\n    onChange: (changedScene : SceneParserResult) => void\n  }\n\n  function SceneParserRow(props : ISceneParserRowProps) {\n\n    function changeParser(result : ParserResult<any>, set : boolean, value : any) {\n      var newParser = _.clone(result);\n      newParser.set = set;\n      newParser.value = value;\n      return newParser;\n    }\n\n    function onTitleChanged(set : boolean, value: string | undefined) {\n      var newResult = _.clone(props.scene);\n      newResult.title = changeParser(newResult.title, set, value);\n      props.onChange(newResult);\n    }\n\n    function onDateChanged(set : boolean, value: string | undefined) {\n      var newResult = _.clone(props.scene);\n      newResult.date = changeParser(newResult.date, set, value);\n      props.onChange(newResult);\n    }\n\n    function onPerformerIdsChanged(set : boolean, value: string[] | undefined) {\n      var newResult = _.clone(props.scene);\n      newResult.performerIds = changeParser(newResult.performerIds, set, value);\n      props.onChange(newResult);\n    }\n\n    function onTagIdsChanged(set : boolean, value: string[] | undefined) {\n      var newResult = _.clone(props.scene);\n      newResult.tagIds = changeParser(newResult.tagIds, set, value);\n      props.onChange(newResult);\n    }\n\n    function onStudioIdChanged(set : boolean, value: string | undefined) {\n      var newResult = _.clone(props.scene);\n      newResult.studioId = changeParser(newResult.studioId, set, value);\n      props.onChange(newResult);\n    }\n\n    return (\n      <tr className=\"scene-parser-row\">\n        <td style={{textAlign: \"left\"}}>\n          {props.scene.filename}\n        </td>\n        <SceneParserField \n          key=\"title\"\n          fieldName=\"Title\"\n          className=\"parser-field-title\" \n          parserResult={props.scene.title}\n          onSetChanged={(set) => onTitleChanged(set, props.scene.title.value)}\n          onValueChanged={(value) => onTitleChanged(props.scene.title.set, value)}\n          renderOriginalInputField={renderOriginalInputGroup}\n          renderNewInputField={renderNewInputGroup}\n        />\n        <SceneParserField \n          key=\"date\"\n          fieldName=\"Date\"\n          className=\"parser-field-date\"\n          parserResult={props.scene.date}\n          onSetChanged={(set) => onDateChanged(set, props.scene.date.value)}\n          onValueChanged={(value) => onDateChanged(props.scene.date.set, value)}\n          renderOriginalInputField={renderOriginalInputGroup}\n          renderNewInputField={renderNewInputGroup}\n        />\n        <SceneParserField \n          key=\"performers\"\n          fieldName=\"Performers\"\n          className=\"parser-field-performers\"\n          parserResult={props.scene.performerIds}\n          originalParserResult={props.scene.performers}\n          onSetChanged={(set) => onPerformerIdsChanged(set, props.scene.performerIds.value)}\n          onValueChanged={(value) => onPerformerIdsChanged(props.scene.performerIds.set, value)}\n          renderOriginalInputField={renderOriginalSelect}\n          renderNewInputField={renderNewPerformerSelect}\n        />\n        <SceneParserField \n          key=\"tags\"\n          fieldName=\"Tags\"\n          className=\"parser-field-tags\"\n          parserResult={props.scene.tagIds}\n          originalParserResult={props.scene.tags}\n          onSetChanged={(set) => onTagIdsChanged(set, props.scene.tagIds.value)}\n          onValueChanged={(value) => onTagIdsChanged(props.scene.tagIds.set, value)}\n          renderOriginalInputField={renderOriginalSelect}\n          renderNewInputField={renderNewTagSelect}\n        />\n        <SceneParserField \n          key=\"studio\"\n          fieldName=\"Studio\"\n          className=\"parser-field-studio\"\n          parserResult={props.scene.studioId}\n          originalParserResult={props.scene.studio}\n          onSetChanged={(set) => onStudioIdChanged(set, props.scene.studioId.value)}\n          onValueChanged={(value) => onStudioIdChanged(props.scene.studioId.set, value)}\n          renderOriginalInputField={renderOriginalSelect}\n          renderNewInputField={renderNewStudioSelect}\n        />\n      </tr>\n    )\n  }\n\n  function onChange(scene : SceneParserResult, changedScene : SceneParserResult) {\n    var newResult = [...parserResult];\n\n    var index = newResult.indexOf(scene);\n    newResult[index] = changedScene;\n\n    setParserResult(newResult);\n  }\n\n  function renderHeader(fieldName: string, allSet: boolean, onAllSet: (set: boolean) => void) {\n    if (!showFields.get(fieldName)) {\n      return null;\n    }\n\n    return (\n      <>\n      <td>\n        <Form.Control\n          type=\"checkbox\"\n          checked={allSet}\n          onChange={() => {onAllSet(!allSet)}}\n        />\n      </td>\n      <th>{fieldName}</th>\n      </>\n    )\n  }\n\n  function renderTable() {\n    if (parserResult.length === 0) { return undefined; }\n\n    return (\n      <>\n      <div>\n        <div className=\"scene-parser-results\">\n          <Table>\n            <thead>\n              <tr className=\"scene-parser-row\">\n                <th>Filename</th>\n                {renderHeader(\"Title\", allTitleSet, onSelectAllTitleSet)}\n                {renderHeader(\"Date\", allDateSet, onSelectAllDateSet)}\n                {renderHeader(\"Performers\", allPerformerSet, onSelectAllPerformerSet)}\n                {renderHeader(\"Tags\", allTagSet, onSelectAllTagSet)}\n                {renderHeader(\"Studio\", allStudioSet, onSelectAllStudioSet)}\n              </tr>\n            </thead>\n            <tbody>\n              {parserResult.map((scene) => \n                <SceneParserRow \n                  scene={scene} \n                  key={scene.id}\n                  onChange={(changedScene) => onChange(scene, changedScene)}/>\n              )}\n            </tbody>\n          </Table>\n        </div>\n        <Pagination\n          currentPage={parserInput.page}\n          itemsPerPage={parserInput.pageSize}\n          totalItems={totalItems}\n          onChangePage={(page) => onPageChanged(page)}\n        />\n        <Button variant=\"primary\" onClick={onApply}>Apply</Button>\n      </div>\n    </>\n    )\n  }\n\n  return (\n    <Card id=\"parser-container\">\n      <h4>Scene Filename Parser</h4>\n      <ParserInput\n        input={parserInput}\n        onFind={(input) => onFindClicked(input)}\n      />\n\n      {isLoading ? <Spinner animation=\"border\" variant=\"light\" /> : undefined}\n      {renderTable()}\n    </Card>\n  );\n};\n  \n","/home/peroo/stash/ui/v2.5/src/components/scenes/SceneList.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/scenes/SceneListTable.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/scenes/SceneMarkerList.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/scenes/ScenePlayer/ScenePlayer.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/scenes/ScenePlayer/ScenePlayerScrubber.tsx",["399","400","401","402","403"],"import axios from \"axios\";\nimport React, { CSSProperties, useEffect, useRef, useState } from \"react\";\nimport * as GQL from \"../../../core/generated-graphql\";\nimport { TextUtils } from \"../../../utils/text\";\nimport \"./ScenePlayerScrubber.scss\";\n\ninterface IScenePlayerScrubberProps {\n  scene: GQL.SceneDataFragment;\n  position: number;\n  onSeek: (seconds: number) => void;\n  onScrolled: () => void;\n}\n\ninterface ISceneSpriteItem {\n  start: number;\n  end: number;\n  x: number;\n  y: number;\n  w: number;\n  h: number;\n}\n\nexport const ScenePlayerScrubber: React.FC<IScenePlayerScrubberProps> = (props: IScenePlayerScrubberProps) => {\n  const contentEl = useRef<HTMLDivElement>(null);\n  const positionIndicatorEl = useRef<HTMLDivElement>(null);\n  const scrubberSliderEl = useRef<HTMLDivElement>(null);\n  const mouseDown = useRef(false);\n  const lastMouseEvent = useRef<any>(null);\n  const startMouseEvent = useRef<any>(null);\n  const velocity = useRef(0);\n\n  const _position = useRef(0);\n  function getPostion() { return _position.current; }\n  function setPosition(newPostion: number, shouldEmit: boolean = true) {\n    if (!scrubberSliderEl.current || !positionIndicatorEl.current) { return; }\n    if (shouldEmit) { props.onScrolled(); }\n\n    const midpointOffset = scrubberSliderEl.current.clientWidth / 2;\n\n    const bounds = getBounds() * -1;\n    if (newPostion > midpointOffset) {\n      _position.current = midpointOffset;\n    } else if (newPostion < bounds - midpointOffset) {\n      _position.current = bounds - midpointOffset;\n    } else {\n      _position.current = newPostion;\n    }\n\n    scrubberSliderEl.current.style.transform = `translateX(${_position.current}px)`;\n\n    const indicatorPosition = (\n      (newPostion - midpointOffset) / (bounds - (midpointOffset * 2)) * scrubberSliderEl.current.clientWidth\n    );\n    positionIndicatorEl.current.style.transform = `translateX(${indicatorPosition}px)`;\n  }\n\n  const [spriteItems, setSpriteItems] = useState<ISceneSpriteItem[]>([]);\n  const [delayedRender, setDelayedRender] = useState(false);\n\n  useEffect(() => {\n    if (!scrubberSliderEl.current) { return; }\n    scrubberSliderEl.current.style.transform = `translateX(${scrubberSliderEl.current.clientWidth / 2}px)`;\n  }, [scrubberSliderEl]);\n\n  useEffect(() => {\n    fetchSpriteInfo();\n  }, [props.scene]);\n\n  useEffect(() => {\n    if (!scrubberSliderEl.current) { return; }\n    const duration = Number(props.scene.file.duration);\n    const percentage = props.position / duration;\n    const position = (\n      (scrubberSliderEl.current.scrollWidth * percentage) - (scrubberSliderEl.current.clientWidth / 2)\n      ) * -1;\n    setPosition(position, false);\n  }, [props.position]);\n\n  useEffect(() => {\n    window.addEventListener(\"mouseup\", onMouseUp, false);\n    return () => {\n      window.removeEventListener(\"mouseup\", onMouseUp);\n    };\n  });\n\n  useEffect(() => {\n    if (!contentEl.current) { return; }\n    contentEl.current.addEventListener(\"mousedown\", onMouseDown, false);\n    return () => {\n      if (!contentEl.current) { return; }\n      contentEl.current.removeEventListener(\"mousedown\", onMouseDown);\n    };\n  });\n\n  useEffect(() => {\n    if (!contentEl.current) { return; }\n    contentEl.current.addEventListener(\"mousemove\", onMouseMove, false);\n    return () => {\n      if (!contentEl.current) { return; }\n      contentEl.current.removeEventListener(\"mousemove\", onMouseMove);\n    };\n  });\n\n  function onMouseUp(this: Window, event: MouseEvent) {\n    if (!startMouseEvent.current || !scrubberSliderEl.current) { return; }\n    mouseDown.current = false;\n    const delta = Math.abs(event.clientX - startMouseEvent.current.clientX);\n    if (delta < 1 && event.target instanceof HTMLDivElement) {\n      const target: HTMLDivElement = event.target;\n      let seekSeconds: number | undefined;\n\n      const spriteIdString = target.getAttribute(\"data-sprite-item-id\");\n      if (spriteIdString != null) {\n        const spritePercentage = event.offsetX / target.clientWidth;\n        const offset = target.offsetLeft + (target.clientWidth * spritePercentage);\n        const percentage = offset / scrubberSliderEl.current.scrollWidth;\n        seekSeconds = percentage * (props.scene.file.duration || 0);\n      }\n\n      const markerIdString = target.getAttribute(\"data-marker-id\");\n      if (markerIdString != null) {\n        const marker = props.scene.scene_markers[Number(markerIdString)];\n        seekSeconds = marker.seconds;\n      }\n\n      if (!!seekSeconds) { props.onSeek(seekSeconds); }\n    } else if (Math.abs(velocity.current) > 25) {\n      const newPosition = getPostion() + (velocity.current * 10);\n      setPosition(newPosition);\n      velocity.current = 0;\n    }\n  }\n\n  function onMouseDown(this: HTMLDivElement, event: MouseEvent) {\n    event.preventDefault();\n    mouseDown.current = true;\n    lastMouseEvent.current = event;\n    startMouseEvent.current = event;\n    velocity.current = 0;\n  }\n\n  function onMouseMove(this: HTMLDivElement, event: MouseEvent) {\n    if (!mouseDown.current) { return; }\n\n    // negative dragging right (past), positive left (future)\n    const delta = event.clientX - lastMouseEvent.current.clientX;\n\n    const movement = event.movementX;\n    velocity.current = movement;\n\n    const newPostion = getPostion() + delta;\n    setPosition(newPostion);\n    lastMouseEvent.current = event;\n  }\n\n  function getBounds(): number {\n    if (!scrubberSliderEl.current || !positionIndicatorEl.current) { return 0; }\n    return scrubberSliderEl.current.scrollWidth - scrubberSliderEl.current.clientWidth;\n  }\n\n  function goBack() {\n    if (!scrubberSliderEl.current) { return; }\n    const newPosition = getPostion() + scrubberSliderEl.current.clientWidth;\n    setPosition(newPosition);\n  }\n\n  function goForward() {\n    if (!scrubberSliderEl.current) { return; }\n    const newPosition = getPostion() - scrubberSliderEl.current.clientWidth;\n    setPosition(newPosition);\n  }\n\n  async function fetchSpriteInfo() {\n    if (!props.scene || !props.scene.paths.vtt) { return; }\n\n    const response = await axios.get<string>(props.scene.paths.vtt, {responseType: \"text\"});\n    if (response.status !== 200) {\n      console.log(response.statusText);\n    }\n\n    // TODO: This is gnarly\n    const lines = response.data.split(\"\\n\");\n    if (lines.shift() !== \"WEBVTT\") { return; }\n    if (lines.shift() !== \"\") { return; }\n    let item: ISceneSpriteItem = {start: 0, end: 0, x: 0, y: 0, w: 0, h: 0};\n    const newSpriteItems: ISceneSpriteItem[] = [];\n    while (lines.length) {\n      const line = lines.shift();\n      if (line === undefined) { continue; }\n\n      if (line.includes(\"#\") && line.includes(\"=\") && line.includes(\",\")) {\n        const size = line.split(\"#\")[1].split(\"=\")[1].split(\",\");\n        item.x = Number(size[0]);\n        item.y = Number(size[1]);\n        item.w = Number(size[2]);\n        item.h = Number(size[3]);\n\n        newSpriteItems.push(item);\n        item = {start: 0, end: 0, x: 0, y: 0, w: 0, h: 0};\n      } else if (line.includes(\" --> \")) {\n        const times = line.split(\" --> \");\n\n        const start = times[0].split(\":\");\n        item.start = (+start[0]) * 60 * 60 + (+start[1]) * 60 + (+start[2]);\n\n        const end = times[1].split(\":\");\n        item.end = (+end[0]) * 60 * 60 + (+end[1]) * 60 + (+end[2]);\n      }\n    }\n\n    setSpriteItems(newSpriteItems);\n    // TODO: Very hacky.  Need to wait for the scroll width to update from the image loading.\n    setTimeout(() => {\n      setDelayedRender(true);\n    }, 100);\n  }\n\n  function renderTags() {\n    function getTagStyle(i: number): CSSProperties {\n      if (!scrubberSliderEl.current ||\n          spriteItems.length === 0 ||\n          getBounds() === 0) { return {}; }\n\n      const tags = window.document.getElementsByClassName(\"scrubber-tag\");\n      if (tags.length === 0) { return {}; }\n\n      let tag: any;\n      for (let index = 0; index < tags.length; index++) {\n        tag = tags.item(index) as any;\n        const id = tag.getAttribute(\"data-marker-id\");\n        if (id === i.toString()) {\n          break;\n        }\n      }\n\n      const marker = props.scene.scene_markers[i];\n      const duration = Number(props.scene.file.duration);\n      const percentage = marker.seconds / duration;\n\n      const left = (scrubberSliderEl.current.scrollWidth * percentage) - (tag.clientWidth / 2);\n      return {\n        left: `${left}px`,\n        height: 20,\n      };\n    }\n\n    return props.scene.scene_markers.map((marker, index) => {\n      const dataAttrs = {\n        \"data-marker-id\": index,\n      };\n      return (\n        <div\n          key={index}\n          className=\"scrubber-tag\"\n          style={getTagStyle(index)}\n          {...dataAttrs}\n        >\n          {marker.title}\n        </div>\n      );\n    });\n  }\n\n  function renderSprites() {\n    function getStyleForSprite(index: number): CSSProperties {\n      if (!props.scene.paths.vtt) { return {}; }\n      const sprite = spriteItems[index];\n      const left = sprite.w * index;\n      const path = props.scene.paths.vtt.replace(\"_thumbs.vtt\", \"_sprite.jpg\"); // TODO: Gnarly\n      return {\n        width: `${sprite.w}px`,\n        height: `${sprite.h}px`,\n        margin: \"0px auto\",\n        backgroundPosition: -sprite.x + \"px \" + -sprite.y + \"px\",\n        backgroundImage: `url(${path})`,\n        left: `${left}px`,\n      };\n    }\n\n    return spriteItems.map((spriteItem, index) => {\n      const dataAttrs = {\n        \"data-sprite-item-id\": index,\n      };\n      return (\n        <div\n          key={index}\n          className=\"scrubber-item\"\n          style={getStyleForSprite(index)}\n          {...dataAttrs}\n        >\n          <span>{TextUtils.secondsToTimestamp(spriteItem.start)} - {TextUtils.secondsToTimestamp(spriteItem.end)}</span>\n        </div>\n      );\n    });\n  }\n\n  return (\n    <div className=\"scrubber-wrapper\">\n      <a className=\"scrubber-button\" id=\"scrubber-back\" onClick={() => goBack()}>&lt;</a>\n      <div ref={contentEl} className=\"scrubber-content\">\n        <div className=\"scrubber-tags-background\" />\n        <div ref={positionIndicatorEl} id=\"scrubber-position-indicator\" />\n        <div id=\"scrubber-current-position\" />\n        <div className=\"scrubber-viewport\">\n          <div ref={scrubberSliderEl} className=\"scrubber-slider\">\n            <div className=\"scrubber-tags\">\n              {renderTags()}\n            </div>\n            {renderSprites()}\n          </div>\n        </div>\n      </div>\n      <a className=\"scrubber-button\" id=\"scrubber-forward\" onClick={() => goForward()}>&gt;</a>\n    </div>\n  );\n};\n","/home/peroo/stash/ui/v2.5/src/components/scenes/SceneSelectedOptions.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/scenes/helpers.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/scenes/scenes.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/select/FilterMultiSelect.tsx",["404","405"],"import * as React from \"react\";\n\nimport { MenuItem } from \"@blueprintjs/core\";\nimport { IMultiSelectProps, ItemPredicate, ItemRenderer, MultiSelect } from \"@blueprintjs/select\";\nimport * as GQL from \"../../core/generated-graphql\";\nimport { StashService } from \"../../core/StashService\";\nimport { HTMLInputProps } from \"../../models\";\nimport { ErrorUtils } from \"../../utils/errors\";\nimport { ToastUtils } from \"../../utils/toasts\";\n\nconst InternalPerformerMultiSelect = MultiSelect.ofType<GQL.AllPerformersForFilterAllPerformers>();\nconst InternalTagMultiSelect = MultiSelect.ofType<GQL.AllTagsForFilterAllTags>();\nconst InternalStudioMultiSelect = MultiSelect.ofType<GQL.AllStudiosForFilterAllStudios>();\n\ntype ValidTypes =\n  GQL.AllPerformersForFilterAllPerformers |\n  GQL.AllTagsForFilterAllTags |\n  GQL.AllStudiosForFilterAllStudios;\n\ninterface IProps extends HTMLInputProps, Partial<IMultiSelectProps<ValidTypes>> {\n  type: \"performers\" | \"studios\" | \"tags\";\n  initialIds?: string[];\n  onUpdate: (items: ValidTypes[]) => void;\n}\n\nexport const FilterMultiSelect: React.FunctionComponent<IProps> = (props: IProps) => {\n  let MultiSelectImpl = getMultiSelectImpl();\n  let InternalMultiSelect = MultiSelectImpl.getInternalMultiSelect();\n  const data = MultiSelectImpl.getData();\n  \n  const [selectedItems, setSelectedItems] = React.useState<ValidTypes[]>([]);\n  const [items, setItems] = React.useState<ValidTypes[]>([]);\n  const [newTagName, setNewTagName] = React.useState<string>(\"\");\n  const createTag = StashService.useTagCreate(getTagInput() as GQL.TagCreateInput);\n\n  React.useEffect(() => {\n    if (!!data) {\n      MultiSelectImpl.translateData();\n    }\n  }, [data]);\n      \n  function getTagInput() {\n    const tagInput: Partial<GQL.TagCreateInput | GQL.TagUpdateInput> = { name: newTagName };\n    return tagInput;\n  }\n\n  async function onCreateNewObject(item: ValidTypes) {\n    var created : any;\n    if (props.type === \"tags\") {\n      try {\n        created = await createTag();\n        \n        items.push(created.data.tagCreate);\n        setItems(items.slice());\n        addSelectedItem(created.data.tagCreate);\n        \n        ToastUtils.success(\"Created tag\");\n      } catch (e) {\n        ErrorUtils.handle(e);\n      }\n    }\n  }\n\n  function createNewTag(query : string) {\n    setNewTagName(query);\n    return {\n      name : query\n    };\n  }\n\n  function createNewRenderer(query: string, active: boolean, handleClick: React.MouseEventHandler<HTMLElement>) {\n    // if tag already exists with that name, then don't return anything\n    if (items.find((item) => {\n      return item.name === query;\n    })) {\n      return undefined;\n    }\n\n    return (\n      <MenuItem\n        icon=\"add\"\n        text={`Create \"${query}\"`}\n        active={active}\n        onClick={handleClick}\n      />\n    );\n  }\n\n  React.useEffect(() => {\n    if (!!props.initialIds && !!items) {\n      const initialItems = items.filter((item) => props.initialIds!.includes(item.id));\n      setSelectedItems(initialItems);\n    }\n  }, [props.initialIds, items]);\n\n  function getMultiSelectImpl() {\n    let getInternalMultiSelect: () => new (props: IMultiSelectProps<any>) => MultiSelect<any>;\n    let getData: () => GQL.AllPerformersForFilterQuery | GQL.AllStudiosForFilterQuery | GQL.AllTagsForFilterQuery | undefined;\n    let translateData: () => void;\n    let createNewObject: ((query : string) => void) | undefined = undefined; \n\n    switch (props.type) {\n      case \"performers\": {\n        getInternalMultiSelect = () => { return InternalPerformerMultiSelect; };\n        getData = () => { const { data } = StashService.useAllPerformersForFilter(); return data; }\n        translateData = () => { let perfData = data as GQL.AllPerformersForFilterQuery; setItems(!!perfData && !!perfData.allPerformers ? perfData.allPerformers : []); };\n        break;\n      }\n      case \"studios\": {\n        getInternalMultiSelect = () => { return InternalStudioMultiSelect; };\n        getData = () => { const { data } = StashService.useAllStudiosForFilter(); return data; }\n        translateData = () => { let studioData = data as GQL.AllStudiosForFilterQuery; setItems(!!studioData && !!studioData.allStudios ? studioData.allStudios : []); };\n        break;\n      }\n      case \"tags\": {\n        getInternalMultiSelect = () => { return InternalTagMultiSelect; };\n        getData = () => { const { data } = StashService.useAllTagsForFilter(); return data; }\n        translateData = () => { let tagData = data as GQL.AllTagsForFilterQuery; setItems(!!tagData && !!tagData.allTags ? tagData.allTags : []); };\n        createNewObject = createNewTag;\n        break;\n      }\n      default: {\n        throw \"Unhandled case in FilterMultiSelect\";\n      }\n    }\n\n    return {\n      getInternalMultiSelect: getInternalMultiSelect,\n      getData: getData,\n      translateData: translateData,\n      createNewObject: createNewObject\n    };\n  }\n\n  const renderItem: ItemRenderer<ValidTypes> = (item, itemProps) => {\n    if (!itemProps.modifiers.matchesPredicate) { return null; }\n    return (\n      <MenuItem\n        active={itemProps.modifiers.active}\n        disabled={itemProps.modifiers.disabled}\n        key={item.id}\n        onClick={itemProps.handleClick}\n        text={item.name}\n      />\n    );\n  };\n\n  const filter: ItemPredicate<ValidTypes> = (query, item) => {\n    if (selectedItems.includes(item)) { return false; }\n    return item.name!.toLowerCase().indexOf(query.toLowerCase()) >= 0;\n  };\n\n  function addSelectedItem(item: ValidTypes) {\n    selectedItems.push(item);\n    setSelectedItems(selectedItems);\n    props.onUpdate(selectedItems);\n  }\n\n  function onItemSelect(item: ValidTypes) {\n    if (item.id === undefined) {\n      // create the new item, if applicable\n      onCreateNewObject(item);\n    } else {\n      addSelectedItem(item);\n    }\n  }\n\n  function onItemRemove(value: string, index: number) {\n    const newSelectedItems = selectedItems.filter((_, i) => i !== index);\n    setSelectedItems(newSelectedItems);\n    props.onUpdate(newSelectedItems);\n  }\n\n  return (\n    <InternalMultiSelect\n      items={items}\n      selectedItems={selectedItems}\n      itemRenderer={renderItem}\n      itemPredicate={filter}\n      tagRenderer={(tag) => tag.name}\n      tagInputProps={{ onRemove: onItemRemove }}\n      onItemSelect={onItemSelect}\n      resetOnSelect={true}\n      popoverProps={{position: \"bottom\"}}\n      createNewItemFromQuery={MultiSelectImpl.createNewObject}\n      createNewItemRenderer={createNewRenderer}\n      {...props}\n    />\n  );\n};\n","/home/peroo/stash/ui/v2.5/src/components/select/FilterSelect.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/select/MarkerTitleSuggest.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/select/ScrapePerformerSuggest.tsx",[],"/home/peroo/stash/ui/v2.5/src/components/select/ValidGalleriesSelect.tsx",[],"/home/peroo/stash/ui/v2.5/src/core/StashService.ts",[],"/home/peroo/stash/ui/v2.5/src/core/generated-graphql.tsx",[],"/home/peroo/stash/ui/v2.5/src/hooks/ListHook.tsx",["406","407","408","409"],"import { Spinner } from \"@blueprintjs/core\";\nimport _ from \"lodash\";\nimport queryString from \"query-string\";\nimport React, { useEffect, useState } from \"react\";\nimport { QueryHookResult } from \"react-apollo-hooks\";\nimport { ListFilter } from \"../components/list/ListFilter\";\nimport { Pagination } from \"../components/list/Pagination\";\nimport { StashService } from \"../core/StashService\";\nimport { IBaseProps } from \"../models\";\nimport { Criterion } from \"../models/list-filter/criteria/criterion\";\nimport { ListFilterModel } from \"../models/list-filter/filter\";\nimport { DisplayMode, FilterMode } from \"../models/list-filter/types\";\n\nexport interface IListHookData {\n  filter: ListFilterModel;\n  template: JSX.Element;\n  options: IListHookOptions;\n  onSelectChange: (id: string, selected : boolean, shiftKey: boolean) => void;\n}\n\ninterface IListHookOperation {\n  text: string;\n  onClick: (result: QueryHookResult<any, any>, filter: ListFilterModel, selectedIds: Set<string>) => void;\n}\n\nexport interface IListHookOptions {\n  filterMode: FilterMode;\n  props: IBaseProps;\n  zoomable?: boolean;\n  otherOperations?: IListHookOperation[];\n  renderContent: (result: QueryHookResult<any, any>, filter: ListFilterModel, selectedIds: Set<string>, zoomIndex: number) => JSX.Element | undefined;\n  renderSelectedOptions?: (result: QueryHookResult<any, any>, selectedIds: Set<string>) => JSX.Element | undefined;\n}\n\nexport class ListHook {\n  public static useList(options: IListHookOptions): IListHookData {\n    const [filter, setFilter] = useState<ListFilterModel>(new ListFilterModel(options.filterMode));\n    const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());\n    const [lastClickedId, setLastClickedId] = useState<string | undefined>(undefined);\n    const [totalCount, setTotalCount] = useState<number>(0);\n    const [zoomIndex, setZoomIndex] = useState<number>(1);\n\n    // Update the filter when the query parameters change\n    useEffect(() => {\n      const queryParams = queryString.parse(options.props.location.search);\n      const newFilter = _.cloneDeep(filter);\n      newFilter.configureFromQueryParameters(queryParams);\n      setFilter(newFilter);\n\n      // TODO: Need this side effect to update the query params properly\n      filter.configureFromQueryParameters(queryParams);\n    }, [options.props.location.search]);\n\n    let result: QueryHookResult<any, any>;\n\n    let getData: (filter : ListFilterModel) => QueryHookResult<any, any>;\n    let getItems: () => any[];\n    let getCount: () => number;\n\n    switch (options.filterMode) {\n      case FilterMode.Scenes: {\n        getData = (filter : ListFilterModel) => { return StashService.useFindScenes(filter); }\n        getItems = () => { return !!result.data && !!result.data.findScenes ? result.data.findScenes.scenes : []; }\n        getCount = () => { return !!result.data && !!result.data.findScenes ? result.data.findScenes.count : 0; }\n        break;\n      }\n      case FilterMode.SceneMarkers: {\n        getData = (filter : ListFilterModel) => { return StashService.useFindSceneMarkers(filter); }\n        getItems = () => { return !!result.data && !!result.data.findSceneMarkers ? result.data.findSceneMarkers.scene_markers : []; }\n        getCount = () => { return !!result.data && !!result.data.findSceneMarkers ? result.data.findSceneMarkers.count : 0; }\n        break;\n      }\n      case FilterMode.Galleries: {\n        getData = (filter : ListFilterModel) => { return StashService.useFindGalleries(filter); }\n        getItems = () => { return !!result.data && !!result.data.findGalleries ? result.data.findGalleries.galleries : []; }\n        getCount = () => { return !!result.data && !!result.data.findGalleries ? result.data.findGalleries.count : 0; }\n        break;\n      }\n      case FilterMode.Studios: {\n        getData = (filter : ListFilterModel) => { return StashService.useFindStudios(filter); }\n        getItems = () => { return !!result.data && !!result.data.findStudios ? result.data.findStudios.studios : []; }\n        getCount = () => { return !!result.data && !!result.data.findStudios ? result.data.findStudios.count : 0; }\n        break;\n      }\n      case FilterMode.Performers: {\n        getData = (filter : ListFilterModel) => { return StashService.useFindPerformers(filter); }\n        getItems = () => { return !!result.data && !!result.data.findPerformers ? result.data.findPerformers.performers : []; }\n        getCount = () => { return !!result.data && !!result.data.findPerformers ? result.data.findPerformers.count : 0; }\n        break;\n      }\n      default: {\n        console.error(\"REMOVE DEFAULT IN LIST HOOK\");\n        getData = (filter : ListFilterModel) => { return StashService.useFindScenes(filter); }\n        getItems = () => { return !!result.data && !!result.data.findScenes ? result.data.findScenes.scenes : []; }\n        getCount = () => { return !!result.data && !!result.data.findScenes ? result.data.findScenes.count : 0; }\n        break;\n      }\n    }\n\n    result = getData(filter);\n\n    useEffect(() => {\n      setTotalCount(getCount());\n\n      // select none when data changes\n      onSelectNone();\n      setLastClickedId(undefined);\n    }, [result.data])\n\n    // Update the query parameters when the data changes\n    useEffect(() => {\n      const location = Object.assign({}, options.props.history.location);\n      location.search = filter.makeQueryParameters();\n      options.props.history.replace(location);\n    }, [result.data, filter.displayMode]);\n\n    // Update the total count\n    useEffect(() => {\n      const newFilter = _.cloneDeep(filter);\n      newFilter.totalCount = totalCount;\n      setFilter(newFilter);\n    }, [totalCount]);\n\n    function onChangePageSize(pageSize: number) {\n      const newFilter = _.cloneDeep(filter);\n      newFilter.itemsPerPage = pageSize;\n      newFilter.currentPage = 1;\n      setFilter(newFilter);\n    }\n\n    function onChangeQuery(query: string) {\n      const newFilter = _.cloneDeep(filter);\n      newFilter.searchTerm = query;\n      newFilter.currentPage = 1;\n      setFilter(newFilter);\n    }\n\n    function onChangeSortDirection(sortDirection: \"asc\" | \"desc\") {\n      const newFilter = _.cloneDeep(filter);\n      newFilter.sortDirection = sortDirection;\n      setFilter(newFilter);\n    }\n\n    function onChangeSortBy(sortBy: string) {\n      const newFilter = _.cloneDeep(filter);\n      newFilter.sortBy = sortBy;\n      newFilter.currentPage = 1;\n      setFilter(newFilter);\n    }\n\n    function onChangeDisplayMode(displayMode: DisplayMode) {\n      const newFilter = _.cloneDeep(filter);\n      newFilter.displayMode = displayMode;\n      setFilter(newFilter);\n    }\n\n    function onAddCriterion(criterion: Criterion, oldId?: string) {\n      const newFilter = _.cloneDeep(filter);\n\n      // Find if we are editing an existing criteria, then modify that.  Or create a new one.\n      const existingIndex = newFilter.criteria.findIndex((c) => {\n        // If we modified an existing criterion, then look for the old id.\n        const id = !!oldId ? oldId : criterion.getId();\n        return c.getId() === id;\n      });\n      if (existingIndex === -1) {\n        newFilter.criteria.push(criterion);\n      } else {\n        newFilter.criteria[existingIndex] = criterion;\n      }\n\n      // Remove duplicate modifiers\n      newFilter.criteria = newFilter.criteria.filter((obj, pos, arr) => {\n        return arr.map((mapObj: any) => mapObj.getId()).indexOf(obj.getId()) === pos;\n      });\n\n      newFilter.currentPage = 1;\n      setFilter(newFilter);\n    }\n\n    function onRemoveCriterion(removedCriterion: Criterion) {\n      const newFilter = _.cloneDeep(filter);\n      newFilter.criteria = newFilter.criteria.filter((criterion) => criterion.getId() !== removedCriterion.getId());\n      newFilter.currentPage = 1;\n      setFilter(newFilter);\n    }\n\n    function onChangePage(page: number) {\n      const newFilter = _.cloneDeep(filter);\n      newFilter.currentPage = page;\n      setFilter(newFilter);\n    }\n\n    function onSelectChange(id: string, selected : boolean, shiftKey: boolean) {\n      if (shiftKey) {\n        multiSelect(id, selected);\n      } else {\n        singleSelect(id, selected);\n      }\n    }\n\n    function singleSelect(id: string, selected: boolean) {\n      setLastClickedId(id);\n      \n      const newSelectedIds = _.clone(selectedIds);\n      if (selected) {\n        newSelectedIds.add(id);\n      } else {\n        newSelectedIds.delete(id);\n      }\n\n      setSelectedIds(newSelectedIds);\n    }\n\n    function multiSelect(id: string, selected : boolean) {\n      let startIndex = 0;\n      let thisIndex = -1;\n  \n      if (!!lastClickedId) {\n        startIndex = getItems().findIndex((item) => {\n          return item.id === lastClickedId;\n        });\n      }\n\n      thisIndex = getItems().findIndex((item) => {\n        return item.id === id;\n      });\n\n      selectRange(startIndex, thisIndex);\n    }\n  \n    function selectRange(startIndex : number, endIndex : number) {\n      if (startIndex > endIndex) {\n        let tmp = startIndex;\n        startIndex = endIndex;\n        endIndex = tmp;\n      }\n  \n      const subset = getItems().slice(startIndex, endIndex + 1);\n      const newSelectedIds : Set<string> = new Set();\n\n      subset.forEach((item) => {\n        newSelectedIds.add(item.id);\n      });\n\n      setSelectedIds(newSelectedIds);\n    }\n\n    function onSelectAll() {\n      const newSelectedIds : Set<string> = new Set();\n      getItems().forEach((item) => {\n        newSelectedIds.add(item.id);\n      });\n\n      setSelectedIds(newSelectedIds);\n      setLastClickedId(undefined);\n    }\n\n    function onSelectNone() {\n      const newSelectedIds : Set<string> = new Set();\n      setSelectedIds(newSelectedIds);\n      setLastClickedId(undefined);\n    }\n\n    function onChangeZoom(newZoomIndex : number) {\n      setZoomIndex(newZoomIndex);\n    }\n\n    const otherOperations = options.otherOperations ? options.otherOperations.map((o) => {\n      return {\n        text: o.text,\n        onClick: () => {\n          o.onClick(result, filter, selectedIds);\n        }\n      }\n    }) : undefined;\n\n    const template = (\n      <div>\n        <ListFilter\n          onChangePageSize={onChangePageSize}\n          onChangeQuery={onChangeQuery}\n          onChangeSortDirection={onChangeSortDirection}\n          onChangeSortBy={onChangeSortBy}\n          onChangeDisplayMode={onChangeDisplayMode}\n          onAddCriterion={onAddCriterion}\n          onRemoveCriterion={onRemoveCriterion}\n          onSelectAll={onSelectAll}\n          onSelectNone={onSelectNone}\n          zoomIndex={options.zoomable ? zoomIndex : undefined}\n          onChangeZoom={options.zoomable ? onChangeZoom : undefined}\n          otherOperations={otherOperations}\n          filter={filter}\n        />\n        {options.renderSelectedOptions && selectedIds.size > 0 ? options.renderSelectedOptions(result, selectedIds) : undefined}\n        {result.loading ? <Spinner size={Spinner.SIZE_LARGE} /> : undefined}\n        {result.error ? <h1>{result.error.message}</h1> : undefined}\n        {options.renderContent(result, filter, selectedIds, zoomIndex)}\n        <Pagination\n          itemsPerPage={filter.itemsPerPage}\n          currentPage={filter.currentPage}\n          totalItems={totalCount}\n          onChangePage={onChangePage}\n        />\n      </div>\n    );\n\n    return { filter, template, options, onSelectChange };\n  }\n}\n","/home/peroo/stash/ui/v2.5/src/hooks/LocalForage.ts",[],"/home/peroo/stash/ui/v2.5/src/hooks/VideoHover.ts",[],"/home/peroo/stash/ui/v2.5/src/index.tsx",[],"/home/peroo/stash/ui/v2.5/src/models/base-props.ts",[],"/home/peroo/stash/ui/v2.5/src/models/index.ts",[],"/home/peroo/stash/ui/v2.5/src/models/list-filter/criteria/criterion.ts",[],"/home/peroo/stash/ui/v2.5/src/models/list-filter/criteria/favorite.ts",[],"/home/peroo/stash/ui/v2.5/src/models/list-filter/criteria/has-markers.ts",[],"/home/peroo/stash/ui/v2.5/src/models/list-filter/criteria/is-missing.ts",[],"/home/peroo/stash/ui/v2.5/src/models/list-filter/criteria/none.ts",[],"/home/peroo/stash/ui/v2.5/src/models/list-filter/criteria/performers.ts",[],"/home/peroo/stash/ui/v2.5/src/models/list-filter/criteria/rating.ts",[],"/home/peroo/stash/ui/v2.5/src/models/list-filter/criteria/resolution.ts",[],"/home/peroo/stash/ui/v2.5/src/models/list-filter/criteria/studios.ts",[],"/home/peroo/stash/ui/v2.5/src/models/list-filter/criteria/tags.ts",[],"/home/peroo/stash/ui/v2.5/src/models/list-filter/criteria/utils.ts",[],"/home/peroo/stash/ui/v2.5/src/models/list-filter/filter.ts",[],"/home/peroo/stash/ui/v2.5/src/models/list-filter/types.ts",[],"/home/peroo/stash/ui/v2.5/src/models/react-images.d.ts",[],"/home/peroo/stash/ui/v2.5/src/models/react-jw-player.d.ts",[],"/home/peroo/stash/ui/v2.5/src/models/types.ts",[],"/home/peroo/stash/ui/v2.5/src/react-app-env.d.ts",[],"/home/peroo/stash/ui/v2.5/src/serviceWorker.ts",[],"/home/peroo/stash/ui/v2.5/src/utils/color.ts",[],"/home/peroo/stash/ui/v2.5/src/utils/editabletext.tsx",[],"/home/peroo/stash/ui/v2.5/src/utils/errors.ts",[],"/home/peroo/stash/ui/v2.5/src/utils/image.tsx",[],"/home/peroo/stash/ui/v2.5/src/utils/navigation.ts",[],"/home/peroo/stash/ui/v2.5/src/utils/table.tsx",[],"/home/peroo/stash/ui/v2.5/src/utils/text.ts",["410"],"export class TextUtils {\n\n  public static truncate(value?: string, limit: number = 100, tail: string = \"...\"): string {\n    if (!value) { return \"\"; }\n    return value.length > limit ? value.substring(0, limit) + tail : value;\n  }\n\n  public static fileSize(bytes: number = 0, precision: number = 2): string {\n    if (isNaN(parseFloat(String(bytes))) || !isFinite(bytes)) { return \"?\"; }\n\n    let unit = 0;\n    while ( bytes >= 1024 ) {\n      bytes /= 1024;\n      unit++;\n    }\n\n    return bytes.toFixed(+precision) + \" \" + this.units[unit];\n  }\n\n  public static secondsToTimestamp(seconds: number): string {\n    let ret = new Date(seconds * 1000).toISOString().substr(11, 8);\n\n    if (ret.startsWith(\"00\")) {\n      // strip hours if under one hour\n      ret = ret.substr(3);\n    }\n    if (ret.startsWith(\"0\")) {\n      // for duration under a minute, leave one leading zero\n      ret = ret.substr(1);\n    }\n    return ret;\n  }\n\n  public static fileNameFromPath(path: string): string {\n    if (!!path === false) { return \"No File Name\"; }\n    return path.replace(/^.*[\\\\\\/]/, \"\");\n  }\n\n  public static age(dateString?: string, fromDateString?: string): number {\n    if (!dateString) { return 0; }\n\n    const birthdate = new Date(dateString);\n    const fromDate = !!fromDateString ? new Date(fromDateString) : new Date();\n\n    let age = fromDate.getFullYear() - birthdate.getFullYear();\n    if (birthdate.getMonth() > fromDate.getMonth() ||\n        (birthdate.getMonth() >= fromDate.getMonth() && birthdate.getDay() > fromDate.getDay())) {\n      age -= 1;\n    }\n\n    return age;\n  }\n\n  public static bitRate(bitrate: number) {\n    const megabits = bitrate / 1000000;\n    return `${megabits.toFixed(2)} megabits per second`;\n  }\n\n  public static resolution(height: number) {\n    if (height >= 240 && height < 480) {\n      return \"240p\";\n    } else if (height >= 480 && height < 720) {\n      return \"480p\";\n    } else if (height >= 720 && height < 1080) {\n      return \"720p\";\n    } else if (height >= 1080 && height < 2160) {\n      return \"1080p\";\n    } else if (height >= 2160) {\n      return \"4K\";\n    } else {\n      return undefined;\n    }\n  }\n\n  private static units = [\n    \"bytes\",\n    \"kB\",\n    \"MB\",\n    \"GB\",\n    \"TB\",\n    \"PB\",\n  ];\n}\n","/home/peroo/stash/ui/v2.5/src/utils/toasts.ts",[],"/home/peroo/stash/ui/v2.5/src/utils/zoom.ts",[],{"ruleId":"411","severity":1,"message":"412","line":20,"column":6,"nodeType":"413","endLine":20,"endColumn":12,"fix":"414"},{"ruleId":"411","severity":1,"message":"415","line":26,"column":6,"nodeType":"413","endLine":26,"endColumn":13,"fix":"416"},{"ruleId":"411","severity":1,"message":"417","line":67,"column":6,"nodeType":"413","endLine":67,"endColumn":12,"fix":"418"},{"ruleId":"411","severity":1,"message":"419","line":49,"column":6,"nodeType":"413","endLine":49,"endColumn":19,"fix":"420"},{"ruleId":"411","severity":1,"message":"421","line":92,"column":6,"nodeType":"413","endLine":92,"endColumn":12,"fix":"422"},{"ruleId":"411","severity":1,"message":"423","line":101,"column":6,"nodeType":"413","endLine":101,"endColumn":20,"fix":"424"},{"ruleId":"411","severity":1,"message":"425","line":117,"column":6,"nodeType":"413","endLine":117,"endColumn":16,"fix":"426"},{"ruleId":"411","severity":1,"message":"412","line":85,"column":6,"nodeType":"413","endLine":85,"endColumn":12,"fix":"427"},{"ruleId":"411","severity":1,"message":"428","line":94,"column":6,"nodeType":"413","endLine":94,"endColumn":17,"fix":"429"},{"ruleId":"411","severity":1,"message":"412","line":28,"column":6,"nodeType":"413","endLine":28,"endColumn":12,"fix":"430"},{"ruleId":"411","severity":1,"message":"431","line":30,"column":3,"nodeType":"432","endLine":30,"endColumn":12,"fix":"433"},{"ruleId":"411","severity":1,"message":"434","line":343,"column":6,"nodeType":"413","endLine":343,"endColumn":19,"fix":"435"},{"ruleId":"411","severity":1,"message":"436","line":448,"column":6,"nodeType":"413","endLine":448,"endColumn":20,"fix":"437"},{"ruleId":"438","severity":1,"message":"439","line":58,"column":10,"nodeType":"432","endLine":58,"endColumn":23},{"ruleId":"411","severity":1,"message":"440","line":67,"column":6,"nodeType":"413","endLine":67,"endColumn":19,"fix":"441"},{"ruleId":"411","severity":1,"message":"442","line":77,"column":6,"nodeType":"413","endLine":77,"endColumn":22,"fix":"443"},{"ruleId":"411","severity":1,"message":"444","line":91,"column":17,"nodeType":"432","endLine":91,"endColumn":24},{"ruleId":"411","severity":1,"message":"444","line":100,"column":17,"nodeType":"432","endLine":100,"endColumn":24},{"ruleId":"411","severity":1,"message":"445","line":40,"column":6,"nodeType":"413","endLine":40,"endColumn":12,"fix":"446"},{"ruleId":"447","severity":1,"message":"448","line":123,"column":9,"nodeType":"449","messageId":"450","endLine":123,"endColumn":53},{"ruleId":"411","severity":1,"message":"451","line":52,"column":8,"nodeType":"413","endLine":52,"endColumn":39,"fix":"452"},{"ruleId":"411","severity":1,"message":"453","line":108,"column":8,"nodeType":"413","endLine":108,"endColumn":21,"fix":"454"},{"ruleId":"411","severity":1,"message":"455","line":115,"column":8,"nodeType":"413","endLine":115,"endColumn":41,"fix":"456"},{"ruleId":"411","severity":1,"message":"451","line":122,"column":8,"nodeType":"413","endLine":122,"endColumn":20,"fix":"457"},{"ruleId":"458","severity":1,"message":"459","line":36,"column":32,"nodeType":"460","messageId":"461","endLine":36,"endColumn":33,"suggestions":"462"},"react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'error' and 'loading'. Either include them or remove the dependency array.","ArrayExpression",{"range":"463","text":"464"},"React Hook useEffect has a missing dependency: 'props.history'. Either include it or remove the dependency array.",{"range":"465","text":"466"},"React Hook useEffect has a missing dependency: 'error'. Either include it or remove the dependency array.",{"range":"467","text":"468"},"React Hook useEffect has a missing dependency: 'config.error'. Either include it or remove the dependency array.",{"range":"469","text":"470"},"React Hook useEffect has missing dependencies: 'filterByLogLevel', 'prependLogEntries', and 'updateFilteredEntries'. Either include them or remove the dependency array.",{"range":"471","text":"472"},"React Hook useEffect has missing dependencies: 'appendLogEntries' and 'updateFilteredEntries'. Either include them or remove the dependency array.",{"range":"473","text":"474"},"React Hook useEffect has a missing dependency: 'updateFilteredEntries'. Either include it or remove the dependency array.",{"range":"475","text":"476"},{"range":"477","text":"464"},"React Hook useEffect has a missing dependency: 'isNew'. Either include it or remove the dependency array.",{"range":"478","text":"479"},{"range":"480","text":"464"},"React Hook useEffect contains a call to 'setTimestamp'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass [props.location.search, timestamp] as a second argument to the useEffect Hook.","Identifier",{"range":"481","text":"482"},"React Hook useEffect has a missing dependency: 'onFind'. Either include it or remove the dependency array.",{"range":"483","text":"484"},"React Hook useEffect has missing dependencies: 'allDateSet', 'allPerformerSet', 'allStudioSet', 'allTagSet', and 'allTitleSet'. Either include them or remove the dependency array.",{"range":"485","text":"486"},"@typescript-eslint/no-unused-vars","'delayedRender' is assigned a value but never used.","React Hook useEffect has a missing dependency: 'fetchSpriteInfo'. Either include it or remove the dependency array.",{"range":"487","text":"488"},"React Hook useEffect has missing dependencies: 'props.scene.file.duration' and 'setPosition'. Either include them or remove the dependency array.",{"range":"489","text":"490"},"The ref value 'contentEl.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'contentEl.current' to a variable inside the effect, and use that variable in the cleanup function.","React Hook React.useEffect has a missing dependency: 'MultiSelectImpl'. Either include it or remove the dependency array.",{"range":"491","text":"492"},"no-throw-literal","Expected an error object to be thrown.","ThrowStatement","object","React Hook useEffect has a missing dependency: 'filter'. Either include it or remove the dependency array.",{"range":"493","text":"494"},"React Hook useEffect has a missing dependency: 'getCount'. Either include it or remove the dependency array.",{"range":"495","text":"496"},"React Hook useEffect has missing dependencies: 'filter' and 'options.props.history'. Either include them or remove the dependency array.",{"range":"497","text":"498"},{"range":"499","text":"500"},"no-useless-escape","Unnecessary escape character: \\/.","Literal","unnecessaryEscape",["501","502"],[766,772],"[data, error, loading]",[983,990],"[props.history, tabId]",[2592,2598],"[data, error]",[1925,1938],"[config.data, config.error]",[2796,2802],"[data, filterByLogLevel, prependLogEntries, updateFilteredEntries]",[3020,3034],"[appendLogEntries, existingData, updateFilteredEntries]",[3422,3432],"[logLevel, updateFilteredEntries]",[4401,4407],[4596,4607],"[isNew, performer]",[1360,1366],[1772,1772],", [props.location.search, timestamp]",[9771,9784],"[onFind, parserInput]",[12750,12764],"[allDateSet, allPerformerSet, allStudioSet, allTagSet, allTitleSet, parserResult]",[2298,2311],"[fetchSpriteInfo, props.scene]",[2667,2683],"[props.position, props.scene.file.duration, setPosition]",[1668,1674],"[MultiSelectImpl, data]",[2305,2336],"[filter, options.props.location.search]",[5171,5184],"[getCount, result.data]",[5448,5481],"[result.data, filter.displayMode, options.props.history, filter]",[5658,5670],"[filter, totalCount]",{"messageId":"503","fix":"504","desc":"505"},{"messageId":"506","fix":"507","desc":"508"},"removeEscape",{"range":"509","text":"510"},"Remove the `\\`. This maintains the current functionality.","escapeBackslash",{"range":"511","text":"512"},"Replace the `\\` with `\\\\` to include the actual backslash character.",[1068,1069],"",[1068,1068],"\\"]